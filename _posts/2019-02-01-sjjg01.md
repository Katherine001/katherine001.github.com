---
layout: post
title:  浙大数据结构学习笔记——第一章
date:   2019-02-01 12:00:00 +0800
categories: 计科
tag: 规划
---

[TOC]



# 一、引入

## 1. 引例1：在书架上摆放图书

### **方法一：**随便放

**【分析】**考虑：

- **怎么查找**？

发现找书非常困难，由此我们优化得到**方法二**

### 方法二：按照书名的拼音字母顺序摆放

**【分析】**考虑：

- 怎么查找？——**二分查找**
- 那怎么插入？

若插入的书以字母A打头，**需要将后面大量的书往后移一格**，非常大的操作，**显然这是不合理的**

**我们需要将自己设身处地，考虑当我们去书店的时候，通常怎么找书呢？**

我们往往按照**书的类别**去对应的位置查找，因此我们得到**方法三**

### 方法三：把书架分成几块区域，每个区域指定摆放某种类别的书，在每种类别下按照书名的拼音字母摆放

**【分析】**

- 插入新书——先定类别，再二分查找确定新书摆放的位置，移出空位
- 查找新书——先定类别，再二分查找

### 总结

解决问题方法的效率和**数据的组织形式**有关

## 2. 引例2：写一个函数打印从1~N的全部正整数，N为函数参数

### 方法一：循环实现

```C
void PrintN(int N)
{
    int i;
    for(i = 1;i <= N;i ++)
    {
        printf("%d\n",i);
    }
    return;
}
```

### 方法二：递归实现

```C
void PrintN(int N)
{
    if(N)
    {
        PrintN(N-1);
        printf("%d\n",N);
    }
    return;
}
```

### 总结

经过测试发现递归实现方法在数据较大的情况下会出现溢出

解决问题方法的效率和**空间利用率**有关

## 3. 引例3：计算多项式在给定点x处的值

**多项式形式：**
$$
f(x)=a_0+a_1x+a_2x^2+...+a_{n-1}x^{n-1}+a_nx^n
$$

```c
double f(int n,double a[],double x)
{
    int i;
    double p = a[0];
    for(i = 1;i <= n;i ++)
    {
        p+=(a[i] * pow(x,i));
    }
    return p;
}
```

将这个多项式利用**结合律**，**每次提出一个x**，多项式形式改造为：
$$
f(x)=a_0+x(a_1+x(a_2+x(...(a_{n-1}+x(a_n))...)))
$$

```c
double f(int n,double a[],double x)
{
    int i;
    double p = a[n];
    for(i = n;i >0;i --)
    {
        p = a[i-1] + x*p;
    }
    return p;
}
```

------

**【补充】**

在C语言中，我们可以用**clock()**函数来测试函数的执行时间，首先我们需要在程序开头加上**头文件time.h**,clock()函数返回的时间单位是**clock tick**，即“**时钟打点**“。

**常数CLK_TCK**:机器时钟每秒所走的时钟打点数。

定义两个clock_t类型的变量start和stop，start在被测函数前面接收clock函数的返回值，stop在被测函数后面接收clock的返回值。

定义一个double类型的duration来接受stop和start的差，具体如下：

```C
double duration = ((double)(stop-start))/CLK_TCK;
```

我们可以利用**称纸片质量**的原理（即**多次重复**执行函数）来得到函数运行一次的时间。

------

**测试两个方法的效率，发现改造后的多项式效率更高**

# 二、数据结构的相关概念

## 1.描述数据对象的组织方式

**逻辑结构**：一般有以下形式：

- 一对一（线性结构）
- 一对多（树形结构）
- 多对多（图结构）

**存储结构**：又称物理存储结构，比如如何存储数据，用数组？还是其它？

## 2.描述数据结构——抽象数据类型

**数据类型：**

- 数据对象集
- 数据集合相关联的操作集

**抽象：**描述数据类型的方法不依赖于具体实现

- 与存放数据的机器无关
- 与数据存储的物理结构无关
- 与实现操作的算法和编程语言均无关

## 3.例子：矩阵的抽象数据类型定义

### 类型名称：

**矩阵（Matrix）**

### 数据对象集：

一个$M*N$的矩阵$A_{m*n}=(a_{ij})(i=1,...,M;j=1,...,N)$由M*N个三元组<$a,i,j$>构成，其中$a$是矩阵元素的值，$i$是元素所在的行号，$j$是元素所在的列号

### 操作集：

- **Matrix Create(int M,int N):**返回一个M*N的空矩阵
- **int GetMaxRow(Matrix A):**返回矩阵A的总行数
- ……

# 三、算法

## 1.定义

**算法（Algorithm）：**

- 一个**有限**的指令集
- 接受一些**输入**（有些情况下不需要输入）
- 产生**输出**
- 一定在**有限步骤**后终止
- 每一条指令必须：
  - 有**充分明确的目标**，不可以有歧义
  - 计算机能处理的范围之内
  - 描述应当**不依赖于**任何一种计算机语言以及具体实现手段

## 2.例子：选择排序算法的伪代码描述

```c
void SelectionSort(int List[],int N)
{
    /*将N个整数List[0]...List[N-1]进行非递减排序*/
    for(int i = 0;i < N;i ++)
    {
        MinPosition = ScanForMin(List,i,N-1);//从List[i]到List[N-1]中找最小元，并将其位置赋给MinPosition
        Swap(List[i],List[MinPosition]);//将未排序的部分的最小元换到有序部分的最后的位置
    }
}
```

**这段伪代码抽象体现在：**

- List到底是数组还是链表？
- Swap用函数还是宏去实现？

**因此伪代码不关注实现细节**

## 3.算法分析

### 3.1 空间复杂度S(n)

根据算法写成的程序在执行时**占用的存储单元的长度**

### 3.2 时间复杂度T(n)

根据算法写成的程序在执行时**耗费时间的长度**

### 3.3 举例分析

#### 例1.

```c
void PrintN(int N)
{
    if(N)
    {
        PrintN(N-1);
        printf("%d\n",N);
    }
    return;
}
```

**空间复杂度分析：**

$S(n)=N*C$

当$N$非常大时，程序就会出现问题

#### 例2.

```c
double f(int n,double a[],double x)
{
    int i;
    double p = a[0];
    for(i = 1;i <= n;i ++)
    {
        p+=(a[i] * pow(x,i));
    }
    return p;
}
```

**时间复杂度分析：**

这个函数做了$1+2+...+n=(n^2+n)/2$次乘法，因此时间复杂度为：
$$
T(n)=C_1n^2+C_2N
$$

```c
double f(int n,double a[],double x)
{
    int i;
    double p = a[n];
    for(i = n;i >0;i --)
    {
        p = a[i-1] + x*p;
    }
    return p;
}
```

**时间复杂度分析：**

这个函数做了n次乘法，因此时间复杂度为：
$$
T(n)=C*n
$$

### 3.4 分析算法的尺度

在分析一般算法效率的时候，我们经常关注下面两种复杂度：

- 最坏情况复杂度$T_{worst}(n)​$
- 平均复杂度$T_{avg}(n)​$

很显然有如下关系：
$$
T_{avg}(n){\leq}T_{worst}(n)
$$
 **我们往往最关心<u>最坏情况复杂度</u>**

### 3.5 复杂度的渐进表示法

$T(n)=O(f(n))$表示存在常数$C>0,n_0>0$使得当$n\geq n_0$时有$T(n)\leq C*f(n)$——**上界**

$T(n)=\Omega (g(n))​$表示存在常数$C>0,n_0>0​$使得当$n\geq n_0​$时有$T(n)\geq C*g(n)​$——**下界**

$T(n)=\Theta(h(n))​$表示同时有$T(n)=O(h(n))​$和$T(n)=\Omega (h(n))​$——**既是上界又是下界**

### 3.6 复杂度分析的小窍门

(1)若两段算法分别有复杂的$T_1(n)=O(f_1(n))​$和$T_2(n)=O(f_2(n))​$，则

- $T_1(n)+T_2(n)=max(O(f_1(n)),O(f_2(n)))​$
- $T_1(n)*T_2(n)=O(f_1(n)*f_2(n))​$

(2)若T(n)是关于n的k阶多项式，那么$T(n)=\Theta(n^k)​$

(3)一个**for循环**的时间复杂度等于循环次数乘以循环体代码的复杂度

(4)**if-else**结构的复杂度取决于if条件判断复杂度和两个分支部分的复杂度，总体复杂度取三者中最大

