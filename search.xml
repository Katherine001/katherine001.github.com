<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>我的第一篇博客--寒假回顾以及开学规划</title>
    <url>/2017/02/15/2017-02-16-review/</url>
    <content><![CDATA[<ul>
<li>content<br>{:toc}</li>
</ul>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>开通博客这件事情，在常人眼里看起来很容易，不就是注册一个帐号吗，我在这之前也是这么认为的。这个寒假，我从sctpan那了解到了利用 jekyll和Github搭建有着自己域名的专属博客。了解到这个想法的时候，我从内心里认为这一定非常麻烦，好在热心的sctpan带着我一步步走，终于也是花了半天的时间将博客成功上线，我的这篇博客最后也会把教程网页分享给大家。<br>好了，接下来谈谈正事。读者可以通过点击下面的两个连接直接跳转到想要阅读的地方。<br><a href="#build01">我的寒假回顾</a><br><a href="#build02">我的开学规划</a><br><a href="#build03">博客实现教程</a></p>
<p id= "build01"></p>
---

<h3 id="寒假生活回顾"><a href="#寒假生活回顾" class="headerlink" title="寒假生活回顾"></a>寒假生活回顾</h3><p>这个寒假，我觉得我可以用一个成语来形容，浑浑噩噩，一点也不为过。放假之前计划好要干的事情，比如听听mooc，刷刷算法题，甚至自学一下c++，也是没能够坚持下去。寒假由于天气寒冷，每天早上起床就已经很晚了。然后紧接着吃午饭，下午时而出去和同学玩，时而在家里刷剧，倒过得挺悠闲。我深知这不是一个计科的人应该的生活。现在想想自己也是挺颓废的了。这个寒假游戏也是没少打，又重温了一下《仙剑4》，和同学在盒子上联机玩了minecraft，好吃的也没有少吃。嘻嘻，是时候该运动起来啦。<br>总而言之，寒假也就这么过去了，也没有什么好挽留的，也许，学校生活能够让我的作息时间表合理起来吧，那接下来，我就来说说我的开学生活规划吧，也算是为自己设定一个小目标。</p>
<p id="build02"></p>
---

<h3 id="我的开学规划"><a href="#我的开学规划" class="headerlink" title="我的开学规划"></a>我的开学规划</h3><p>我所在的学校是师范类型的学校，周围也很少人真正认真去学习这一专业，包括我也是，大一时候也没有学习过这一专业，也错过了计算机专业最核心的一门课–数据结构，虽然还是及格了，要说实际应用到算法的实现中，我应该还算是个门外汉。所以一方面我在mooc上选了一门浙江大学的数据结构，差不多3月份开始，每个星期花那么点时间重新把数据结构给学扎实，下学期我也需要准备蓝桥杯竞赛，数据结构和算法的学习也是相辅相成的，希望能够取得一个好成绩吧，最后一方面有关专业的就是学习一门新的语言python，可能有人会推荐c++，但我觉得c++也只需要了解c语言不具有的，一方面有关面向对象特性的，还有一方面stl库的使用，因为这可以大大方便我们使用一些数据结构。<br>除了有关学习，我觉得我还需要开阔我的视野，多读几本好书，多去外面转转，我个人觉得我在人际关系处理方面还有欠缺，从我和室友的关系方面就可以看出，我也希望我能通过自己的努力，一方面不耽误自己学习，另一方面能够和形形色色的人打交道，早日成为更好的自己！</p>
<p id="build03"></p>
---

<h3 id="博客教程分享"><a href="#博客教程分享" class="headerlink" title="博客教程分享"></a>博客教程分享</h3><p>下面是几个教程，感兴趣的可以了解一下<br>1.<a href="https://bigballon.github.io/posts/jekyll-github.html">jekyll+github搭建个人博客</a><br>2.<a href="http://jekyllcn.com/">jekyll中文详细教程</a><br>3.<a href="http://www.appinn.com/markdown/index.html#misc">MareDown中文教程</a></p>
<p>—Alisa 写于  江苏苏州<br>2017.02.16  </p>
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>










]]></content>
      <categories>
        <category>Random thoughts</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>OJ编程题输入数据处理</title>
    <url>/2017/02/23/2017-02-24-cin/</url>
    <content><![CDATA[<ul>
<li>content<br>{:toc}</li>
</ul>
<p>现在越来越多的学校使用了OJ（online jude）平台，在上面发布比赛，通过编译运行选手们提交的代码来获取输出结果，与题目所给的正确输出结果对比，来判断参赛选手的代码正确性。那么我们在使用OJ平台刷题时，也需要根据题目意思注意一下最基本的输入数据处理。  </p>
<p>首先，我们先来讨论一个细节问题。  </p>
<p>C语言中的scanf函数想必大家再熟悉不过了，但肯定会有很多人，不知道这个函数也是有返回值的，我们先来看一下如下一段代码：  </p>
<p><strong>代码1</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m));</span><br></pre></td></tr></table></figure>
<p>执行此代码，我们可以发现，scanf(…)表达式的值为int,表示的是成功读入的变量的个数。下面提供了几组输入数据  </p>
<p>输入：12 56&lt;回车&gt;   输出：2   </p>
<p>输入：40 a&lt;回车&gt;   输出：1   </p>
<p>分析这两组数据，我们可以发现如果用户输入的数据类型与指定的数据类型不同，是不能被记作成功读入变量。如果遇到了下面这种情况:   </p>
<p>输入：a 40&lt;回车&gt;   输出：0   </p>
<p>可见，只要第一个没有成功读入，该函数也不会继续执行下去了。 还有一点，scanf表达式的值为EOF，则说明输入数据已经结束。   </p>
<p>下面这个例子，就是利用这个特征实现用户不断输入两个值来计算他们的和。   </p>
<p><strong>代码2</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m)!=EOF)<span class="comment">//EOF是直接能够拿来用的</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,n+m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不停输入两个整数再敲回车，则不停输出他们的和，在windows系统下，如果CTRL+Z，然后回车，程序就能结束.  </p>
<p>那我们在C++中的cin表达式同样也具有返回值，返回值为布尔类型，在成功读入所有变量时，返回值为true，否则为false。同样可以实现和代码1相同的功能:  </p>
<p><strong>代码3</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,n+m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们来看一个实例<br>例题：输入若干个正整数，输出其中最大值.  </p>
<p>Sample Input:<br>2 3 5 6 8 25 88 77<br>Sample Output:<br>88  </p>
<p>思路：我们只需通过前面所学，不断输入符合数据类型的值，输入一个判断一个，如果输入后面的值比前面大，则更新大的值。  </p>
<p>实现代码：<br><strong>代码4</strong>  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> m,mx;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;m)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(m &gt; mx)</span><br><span class="line">    mx = m;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;mx;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可见一些必要的，却容易被我们忽视的细节问题，如果处理得当，亦可以使一些问题简洁很多，而这些恰恰需要我们去不断探索。</p>
<p>—Alisa 写于  江苏泰州<br>2017.02.24</p>
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"alisa"};

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">	var ds &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line">	ds.type &#x3D; &#39;text&#x2F;javascript&#39;;ds.async &#x3D; true;</span><br><span class="line">	ds.src &#x3D; (document.location.protocol &#x3D;&#x3D; &#39;https:&#39; ? &#39;https:&#39; : &#39;http:&#39;) + &#39;&#x2F;&#x2F;static.duoshuo.com&#x2F;embed.js&#39;;</span><br><span class="line">	ds.charset &#x3D; &#39;UTF-8&#39;;</span><br><span class="line">	(document.getElementsByTagName(&#39;head&#39;)[0] </span><br><span class="line">	 || document.getElementsByTagName(&#39;body&#39;)[0]).appendChild(ds);</span><br><span class="line">&#125;)();</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<!-- 多说公共JS代码 end -->


<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>




]]></content>
      <categories>
        <category>Summary</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>数组的综合运用</title>
    <url>/2017/03/03/2017-03-04-prime/</url>
    <content><![CDATA[<ul>
<li>content<br>{:toc}</li>
</ul>
<h1 id="题目：有正整数n（n-gt-2）-求不大于n的全部素数"><a href="#题目：有正整数n（n-gt-2）-求不大于n的全部素数" class="headerlink" title="题目：有正整数n（n&gt;=2）,求不大于n的全部素数"></a>题目：有正整数n（n&gt;=2）,求不大于n的全部素数</h1><p>这是一个很简单，然而又很经典的算法问题。对于初学程序设计语言的人，在学到循环章节必然会遇到这道题，解法也很简单，结合取模运算和二重循环即可求解。  </p>
<h2 id="常规解法"><a href="#常规解法" class="headerlink" title="常规解法"></a>常规解法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">for</span>( k = <span class="number">2</span>; k &lt; i; ++k )</span><br><span class="line">    &#123;</span><br><span class="line">          <span class="keyword">if</span>( i % k == <span class="number">0</span> )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( k == i )</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这种解法，有几个弊端，就是做了没有必要的尝试，k大于i的平方根以后就没必要再尝试了，具体的原因读者结合数学想想也就明白了。还有，除2以外偶数也显然不是素数，所以在程序的优化中也应该考虑这一点。下面是优化后的代码。  </p>
<h2 id="常规解法（优化版）"><a href="#常规解法（优化版）" class="headerlink" title="常规解法（优化版）"></a>常规解法（优化版）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//先把特殊情况素数2输出</span></span><br><span class="line">  <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i += <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//每次判断i是否是素数</span></span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">for</span>( k = <span class="number">3</span>; k &lt; i; k += <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>( i % k == <span class="number">0</span> )  <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span>( k * k &gt; i )  <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( k * k &gt; i )  <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们学习了一维数组以后，我们也可以结合其知识来设计出一个更加快的算法，其思路是：把2到n中的所有数都列出来，然后从2开始，先划掉n以内所有2的倍数，然后每次从下一个剩下的数（必然是素数）开始，划掉其n内的所有倍数。最后剩下的数就都是素数。我们把这个方法称为<strong>筛法求素数</strong>。<br>实际实现这个算法，和前面的算法不同，我们需要设置一个标志数组<strong>isPrime</strong>，isPrime[i]的值是1，代表i是素数，当然，我们一开始把所有数组元素值都赋予1。<br>然后，我们划掉k的倍数，就是把isPrime[ 2 * k ]，isPrime[ 3 * k ]……置为0。<br>最后检查isPrime数组，输出isPrime[i]为1的那些i。  </p>
<h2 id="筛法求素数代码"><a href="#筛法求素数代码" class="headerlink" title="筛法求素数代码"></a>筛法求素数代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_NUM 10000</span></span><br><span class="line"><span class="keyword">char</span> isPrime[MAX_NUM + <span class="number">1</span>];<span class="comment">//最终如果isPrime[i]为1，则表示i是素数，定义为char类型可以节省存储空间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX_NUM; ++i )<span class="comment">//开始假设所有数都是素数</span></span><br><span class="line">    isPrime[i] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;=MAX_NUM; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//每次将一个素数的所有倍数标记为非素数</span></span><br><span class="line">    <span class="keyword">if</span>(isPrime[i])<span class="comment">//只标记素数的倍数</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">2</span> * i; j &lt;= MAX_NUM; j += i )</span><br><span class="line">    isPrime[j] = <span class="number">0</span>;<span class="comment">//将素数i的倍数标记为非素数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX_NUM; ++i)</span><br><span class="line">  <span class="keyword">if</span>( isPrime[i] )</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>小结</strong>  </p>
<p>本算法也体现了一个思想，就是我们在内存够用的时候，也可以通过内存换时间，加快算法的计算速度。  </p>
<p>—Alisa 写于  江苏泰州<br>2017.03.04  </p>
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>



]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>最大子列和问题的多解</title>
    <url>/2017/03/07/2017-03-08-fenzhi/</url>
    <content><![CDATA[<ul>
<li>content<br>{:toc}</li>
</ul>
<h1 id="问题描述：给定N个整数序列，-A1-A2-…-An-求该序列中存在的最大的连续n个整数和。"><a href="#问题描述：给定N个整数序列，-A1-A2-…-An-求该序列中存在的最大的连续n个整数和。" class="headerlink" title="问题描述：给定N个整数序列，{A1,A2,…,An},求该序列中存在的最大的连续n个整数和。"></a>问题描述：给定N个整数序列，{A1,A2,…,An},求该序列中存在的<strong>最大的连续n个整数和</strong>。</h1><p>要解决这个问题，我们很容易想到，可以把所有的连续子列和全部算出来，然后从中找出最大的一个即为所求答案，算法代码如下：  </p>
<h2 id="原始代码"><a href="#原始代码" class="headerlink" title="原始代码"></a>原始代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubseqSum1</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i,j,k;</span><br><span class="line">  <span class="keyword">int</span> ThisSum,MaxSum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>( i = <span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/*i是子列左端位置*/</span></span><br><span class="line">    <span class="keyword">for</span>( j = i; j&lt;N; j++ )</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">/*j是子列右端的位置*/</span></span><br><span class="line">       ThisSum = <span class="number">0</span>;<span class="comment">/*ThisSum是从A[i]到A[j]的子列和*/</span></span><br><span class="line">       <span class="keyword">for</span>( k = i; k &lt;=j; k++ )</span><br><span class="line">       ThisSum += A[k];</span><br><span class="line">       <span class="keyword">if</span>(ThisSum&gt;MaxSum)</span><br><span class="line">       MaxSum = ThisSum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">return</span> MaxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个算法很容易想到，当然该算法的时间复杂度也是大的可怕，为T(N)=O(N^3)</p>
<p>仔细分析该算法，发现该算法做了无用功，当j增加1时，我们没有必要从头算起，我们只要在前面i<del>j的部分和后面加一个元素就行，没有必要重新算前面i</del>j部分和，也就是说，k循环是多余的。</p>
<p>那我们优化后的代码如下：  </p>
<h2 id="优化代码"><a href="#优化代码" class="headerlink" title="优化代码"></a>优化代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubseqSum2</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i,j;</span><br><span class="line">  <span class="keyword">int</span> ThisSum,MaxSum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>( i = <span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/*i是子列左端位置*/</span></span><br><span class="line">    ThisSum = <span class="number">0</span>;<span class="comment">/*ThisSum是从A[i]到A[j]的子列和*/</span></span><br><span class="line">    <span class="keyword">for</span>( j = i; j&lt;N; j++ )</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">/*j是子列右端的位置*/</span></span><br><span class="line">       ThisSum += A[j];</span><br><span class="line">       <span class="keyword">if</span>(ThisSum&gt;MaxSum)</span><br><span class="line">       MaxSum = ThisSum;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> MaxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该算法时间复杂度为T(N) = O(N^2)，较第一个算法快一些。</p>
<p>那还有没有更快的算法了呢？答案是肯定的。我们可以应用<strong>分而治之</strong>的思想去解决这一道题目。<br>什么是<strong>分而治之</strong>呢？参见<a href="http://baike.baidu.com/link?url=qbcobNUjewEjuwHF51tRRWyFNXeN1f5WPynd-rzXy5OKqiOhJJ6nh76UBdE50-OJykfLjBysDay7e_tuAh_wUtrd0mrGXQcxvuksxUpSt-Bv0N76xssT8-XiP5A3oFOwtwLrDJe3c3K8cuUndbMxRK">分而治之</a>。</p>
<p>解题思路：把数组从中间一分为二，然后递归地去解决左右两边的问题，分别得到左右两边的最大子列和，但此时我们还不能下定论，还需要考虑跨越边界的最大子列和，即得到这三个结果，返回其中的最大值。代码如下:  </p>
<h2 id="分而治之法"><a href="#分而治之法" class="headerlink" title="分而治之法"></a>分而治之法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B, <span class="keyword">int</span> C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*return A &gt; B ? A &gt; C ? A :C: B &gt; C ? B : C;*/</span></span><br><span class="line">    <span class="keyword">if</span> (A &gt; B) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A &gt; C)</span><br><span class="line">            <span class="keyword">return</span> A;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> C;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (B &gt; C)</span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> C;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DivideAndConquer</span><span class="params">(<span class="keyword">int</span> List[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> MaxLeftSum, MaxRightSum;</span><br><span class="line">    <span class="keyword">int</span> MaxLeftBoardSum, MaxRightBoardSum;</span><br><span class="line">    <span class="keyword">int</span> LeftBoardSum, RightBoardSum;</span><br><span class="line">    <span class="keyword">int</span> center,i;</span><br><span class="line">    <span class="comment">/*递归终止条件*/</span></span><br><span class="line">    <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (List[left] &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> List[left];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    center = (right + left) / <span class="number">2</span>;</span><br><span class="line">    MaxLeftSum = DivideAndConquer(List, left, center);</span><br><span class="line">    MaxRightSum= DivideAndConquer(List, center+<span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">    MaxLeftBoardSum = <span class="number">0</span>; LeftBoardSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = center;i &gt;= left; i--)</span><br><span class="line">        LeftBoardSum += List[i];</span><br><span class="line">    <span class="keyword">if</span> (LeftBoardSum &gt; MaxLeftBoardSum)</span><br><span class="line">        MaxLeftBoardSum = LeftBoardSum;</span><br><span class="line">    MaxRightBoardSum = <span class="number">0</span>; RightBoardSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = center + <span class="number">1</span>; i &lt;= right; i++)</span><br><span class="line">        RightBoardSum += List[i];</span><br><span class="line">    <span class="keyword">if</span> (RightBoardSum &gt; MaxRightBoardSum)</span><br><span class="line">        MaxRightBoardSum = RightBoardSum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Max(MaxLeftSum, MaxRightSum, MaxRightBoardSum + MaxLeftBoardSum);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxsequence3</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DivideAndConquer(A, <span class="number">0</span>, N<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该算法的时间复杂度为T(N)=O(  N * logN )，较之前的两个算法有很大的改进。  </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>把一个大规模的问题，化简为几个小问题，分别解决每个小问题，我们便可以轻松得到问题的答案。由此可见<strong>递归</strong>的思想的重要性。</p>
<p><strong>最后，祝愿所有女性朋友们女神节快乐！</strong></p>
<p>—Alisa 写于 江苏泰州 2017.03.08</p>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构典型问题——表达式求值</title>
    <url>/2017/03/20/2017-03-21-lanqiao01/</url>
    <content><![CDATA[<ul>
<li>content<br>{:toc}</li>
</ul>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>好久没有更新博客了，因为没过多久就要蓝桥杯比赛了，在蓝桥杯的官网上也有一个题库，里面有些算法题，今天的算法题也是出自里面的。  </p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个只包含加减乖除和括号的合法表达式，求表达式的值。其中除表示整除。  </p>
<p>输入格式<br>输入一行，包含一个表达式。  </p>
<p>输出格式<br>输出这个表达式的值。  </p>
<p>样例输入<br>1-2+3 * ( 4-5 )<br>样例输出<br>-4  </p>
<p>数据规模和约定<br>表达式长度不超过100，表达式运算合法且运算过程都在int内进行。  </p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>开两个栈一个是符号栈一个是数栈,然后依次读取输入的字符串如果是数字就转化成数并入栈,如果是运算符就比较运算符优先级进行计算,这里我们将运算符打表,然后在字符串的头和尾都增加一个#来判断边缘情况。  </p>
<p>栈底的字符#,是用来判断第一个运算符的时候,如果不加#这是从运算符栈取出的为空,无法计算。  </p>
<p>栈顶的字符#，是因为我们输入的字符串中的运算符经过大小比较的运算最终会剩下一个,如果没有这个末尾的#，那么运算没有结束,数栈中也会剩余数,运算符栈也会剩下一个,我们增加这个#，由于#的优先级最低,会将最后一个运算符计算出。  </p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">110</span>];</span><br><span class="line"><span class="keyword">char</span> pre[<span class="number">7</span>][<span class="number">7</span>]=&#123;</span><br><span class="line">	&#123;<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;=&#x27;</span>,<span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;=&#x27;</span>&#125;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">procede</span><span class="params">(<span class="keyword">char</span> a,<span class="keyword">char</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">switch</span>(a)</span><br><span class="line">	&#123;</span><br><span class="line">		case&#x27;+&#x27;:i=0;break;</span><br><span class="line">		case&#x27;-&#x27;:i=1;break;</span><br><span class="line">		case&#x27;*&#x27;:i=2;break;</span><br><span class="line">		case&#x27;/&#x27;:i=3;break;</span><br><span class="line">		case&#x27;(&#x27;:i=4;break;</span><br><span class="line">		case&#x27;)&#x27;:i=5;break;</span><br><span class="line">		case&#x27;#&#x27;:i=6;break;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">switch</span>(b)</span><br><span class="line">	&#123;</span><br><span class="line">		case&#x27;+&#x27;:j=0;break;</span><br><span class="line">		case&#x27;-&#x27;:j=1;break;</span><br><span class="line">		case&#x27;*&#x27;:j=2;break;</span><br><span class="line">		case&#x27;/&#x27;:j=3;break;</span><br><span class="line">		case&#x27;(&#x27;:j=4;break;</span><br><span class="line">		case&#x27;)&#x27;:j=5;break;</span><br><span class="line">		case&#x27;#&#x27;:j=6;break;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pre[i][j];</span><br><span class="line">&#125;	</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">operate</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n,<span class="keyword">char</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">	<span class="keyword">return</span> m+n;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">	<span class="keyword">return</span> n-m;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">	<span class="keyword">return</span> m*n;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">	<span class="keyword">return</span> n/m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k,y;</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;shu;	</span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line">	<span class="keyword">char</span> ss[<span class="number">2</span>]=<span class="string">&quot;#&quot;</span>;</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt;fu;</span><br><span class="line">	fu.push(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">	gets(s);</span><br><span class="line">	<span class="built_in">strcat</span>(s,ss); </span><br><span class="line">	c=s[<span class="number">0</span>];</span><br><span class="line">	k=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(c!=<span class="string">&#x27;#&#x27;</span>||fu.top()!=<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		y=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				y=y*<span class="number">10</span>+(c-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">				c=s[k++];</span><br><span class="line">			&#125;</span><br><span class="line">			shu.push(y);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">switch</span>(procede(fu.top(),c))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">case</span><span class="number">&#x27;</span>&lt;<span class="string">&#x27;:</span></span><br><span class="line">					fu.push(c);</span><br><span class="line">					c=s[k++];</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span><span class="number">&#x27;</span>=<span class="string">&#x27;:</span></span><br><span class="line">					fu.pop();</span><br><span class="line">					c=s[k++];</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span><span class="number">&#x27;</span>&gt;<span class="string">&#x27;:</span></span><br><span class="line">					char x=fu.top();fu.pop();</span><br><span class="line">					<span class="keyword">int</span> m=shu.top();shu.pop();</span><br><span class="line">					<span class="keyword">int</span> n=shu.top();shu.pop();</span><br><span class="line">					shu.push(operate(m,n,x));</span><br><span class="line">					<span class="keyword">break</span>;	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,shu.top());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构典型问题——单链表操作综合应用</title>
    <url>/2017/04/05/2017-04-06-lanqiao02/</url>
    <content><![CDATA[<ul>
<li>content<br>{:toc}</li>
</ul>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近开始恶补数据结构基础，所以本次更新一道数据结构入门题。  </p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>将一个单链表拆分为3个单链表</p>
<p>假设有一个带头节点的单链表L，每个节点值由单个数字、小写字母和大写字母构成。设计一个算法将其拆分成3个带头节点的单链表L1、L2和L3，L1包含L中的所有数字节点，L2包含L中的所有小写字母节点，L3包含L中的所有大写字母节点。</p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>利用尾插法建3个单链表，遍历已知单链表，把数据域符合条件的节点筛选出来插入相应的单链表中即可。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 30</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType str;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>    </span><br><span class="line">&#125; LinkList;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(LinkList *&amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L = (LinkList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CreateList</span><span class="params">(LinkList *&amp;L, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    LinkList *s;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s = (LinkList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;s-&gt;str);</span><br><span class="line">        s-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = s;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">(LinkList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList *p = L-&gt;next;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, p-&gt;str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c-&gt;&quot;</span>, p-&gt;str);</span><br><span class="line">        &#125; </span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NumLinkList</span><span class="params">(LinkList *L, LinkList *&amp;L1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList *s, *p = L-&gt;next, *r = L1;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;str &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; p-&gt;str &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s = (LinkList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">            s-&gt;str = p-&gt;str;</span><br><span class="line">            r-&gt;next = s;</span><br><span class="line">            r = s;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpLinkList</span><span class="params">(LinkList *L, LinkList *&amp;L2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList *s, *p = L-&gt;next, *r = L2;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;str &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; p-&gt;str &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s = (LinkList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">            s-&gt;str = p-&gt;str;</span><br><span class="line">            r-&gt;next = s;</span><br><span class="line">            r = s;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LoLinkList</span><span class="params">(LinkList *L, LinkList *&amp;L3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList *s, *p = L-&gt;next, *r = L3;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;str &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; p-&gt;str &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s = (LinkList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">            s-&gt;str = p-&gt;str;</span><br><span class="line">            r-&gt;next = s;</span><br><span class="line">            r = s;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList *L, *L1, *L2, *L3;</span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    ElemType a[MaxSize];</span><br><span class="line">    InitList(L);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please input the numbers of nodes you want to create:&quot;</span>);    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please input the nodes&#x27;s data:&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(CreateList(L, n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Input Successfully!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Linked List:&quot;</span>);</span><br><span class="line">    PrintList(L);</span><br><span class="line">     </span><br><span class="line">    InitList(L1);</span><br><span class="line">    InitList(L2);</span><br><span class="line">    InitList(L3);</span><br><span class="line">     </span><br><span class="line">    NumLinkList(L, L1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Number Linked List:&quot;</span>); </span><br><span class="line">    PrintList(L1);</span><br><span class="line">    UpLinkList(L, L2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Uppercase Linked List:&quot;</span>); </span><br><span class="line">    PrintList(L2);</span><br><span class="line">    LoLinkList(L, L3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Lowercase Linked List:&quot;</span>); </span><br><span class="line">    PrintList(L3);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>——Alisa写于 江苏泰州  2017.04.06</p>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>五月小结</title>
    <url>/2017/05/30/2017-06-01-5summar/</url>
    <content><![CDATA[<ul>
<li>content<br>{:toc}<br>时间过得真快啊，距离放假又只有一个月了，仿佛感觉昨天才刚开学。期初给自己定的目标虽然也在尽力去完成，但是还是感觉自己荒废了很多时间，学习好像也一直不在状态。<br>在过去的5月份，我尝试着去每天早起1小时去背一些英语单词，读一些英语美文，对于我而言，英语底子比较弱。因此我认为英语的学习还是打基础为主，任何的考试其核心就在于词汇量和阅读能力上。<br>专业课的学习方面，Android的学习让我认识到对于算法和数据库原理的理解程度，直接会反映到所完成项目的质量上，因此，当学习遇到瓶颈的时候，更要去回头看看以前的基础知识，只有不断运用映像才会更加深刻。对于学校这学期开设的数字电路课程，我感觉自己学得迷迷糊糊，上课上着上着就打瞌睡了~~实在惭愧啊。从4月初开始到现在，我每天也花一点时间去回顾数据结构的内容，直到现在也才啃了一半。对于以后的考研来说，数据结构非常的重要，里面的知识点也非常多，所以还是需要多花一点时间。<br>还有不到一个月，各种考试接踵而来，虽然自己很反感为了考试而学习，但是学分和绩点是很现实的问题，因此6月需要我再辛苦一点了。<br>总体来说，我觉得自己的学习状态还是比较差的，有很多时候感觉时间没能充分利用好，但是我希望每一天我都能效率提高一点，前方的路还很长，唯有坚持住才能不断成长，早日实现自己的梦想，为以后的美好生活做好铺垫。<br>最后，祝大家六一快乐，永远保持着一颗年轻的心！<br>——Alisa写于江苏泰州<br>2017.06.01</li>
</ul>
]]></content>
      <categories>
        <category>Random thoughts</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>OJ编程题输入输出数据处理（标准文档）</title>
    <url>/2017/06/02/2017-06-03-enter/</url>
    <content><![CDATA[<ul>
<li>content<br>{:toc}<h1 id="在ACM竞赛中，对于数据的读入，一般有以下四种情况："><a href="#在ACM竞赛中，对于数据的读入，一般有以下四种情况：" class="headerlink" title="在ACM竞赛中，对于数据的读入，一般有以下四种情况："></a><strong>在ACM竞赛中，对于数据的读入，一般有以下四种情况：</strong></h1></li>
</ul>
<h2 id="一、四种基本输入形式："><a href="#一、四种基本输入形式：" class="headerlink" title="一、四种基本输入形式："></a>一、四种基本输入形式：</h2><h3 id="单组输入数据"><a href="#单组输入数据" class="headerlink" title="单组输入数据"></a>单组输入数据</h3><p>示例： <a href="http://acm.njupt.edu.cn/acmhome/problemdetail.do?&method=showdetail&id=1001">整数求和</a><br>C语言：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> a,b;  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a, &amp;b);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a+b);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>C++：    </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> a,b;  </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a+b&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p><strong>注意：输入前无需也不要输出任何提示信息。</strong>  </p>
<h3 id="多组输入数据，且不说明多少组，直到读至输入文件末尾为止"><a href="#多组输入数据，且不说明多少组，直到读至输入文件末尾为止" class="headerlink" title="多组输入数据，且不说明多少组，直到读至输入文件末尾为止"></a>多组输入数据，且不说明多少组，直到读至输入文件末尾为止</h3><p>示例： <a href="http://acm.njupt.edu.cn/acmhome/problemdetail.do?&method=showdetail&id=1084">A + B Problem (1)</a><br>C语言：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b) != EOF)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a+b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：scanf函数返回值就是读出的变量个数，如：scanf( “%d %d”, &amp;a, &amp;b );如果只有输入了一个整数，返回值是1，如果输入了两个，返回值是2，如果一个都没有，则返回值是EOF。EOF是一个预定义的常量，等于-1</strong><br>C++：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a+b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：表达式cin &gt;&gt; m &gt;&gt; n在读入发生错误返回0，否则返回cin的地址。</strong>  </p>
<h3 id="多组输入数据，不说明多少组，以某特殊输入为结束标志。"><a href="#多组输入数据，不说明多少组，以某特殊输入为结束标志。" class="headerlink" title="多组输入数据，不说明多少组，以某特殊输入为结束标志。"></a>多组输入数据，不说明多少组，以某特殊输入为结束标志。</h3><p>示例：<a href="http://acm.njupt.edu.cn/acmhome/problemdetail.do?&method=showdetail&id=1085">A + B Problem (2)</a><br>C语言：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="keyword">if</span>(a==<span class="number">0</span>&amp;&amp;b==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a+b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++：  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">0</span>&amp;&amp;b==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a+b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：当读入的a与b同时为0时，程序终止；</strong>  </p>
<h3 id="多组输入数据，开始输入一个T，接下来是T组数据"><a href="#多组输入数据，开始输入一个T，接下来是T组数据" class="headerlink" title="多组输入数据，开始输入一个T，接下来是T组数据"></a>多组输入数据，开始输入一个T，接下来是T组数据</h3><p>示例：<a href="http://acm.njupt.edu.cn/acmhome/problemdetail.do?&method=showdetail&id=1086">A + B Problem (3)</a><br>C语言：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a+b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++：  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a+b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：当T组数据处理完后，程序终止；</strong>  </p>
<p>关于字符串的读入，这里再做专门讨论：  </p>
<h2 id="二、字符串输入"><a href="#二、字符串输入" class="headerlink" title="二、字符串输入"></a>二、字符串输入</h2><p>对字符串的输入分三种情况：<br>1、每个字符串中不含空格、制表符及回车,这种情况，用scanf函数是再好不过的了；<br>例如：要读入字符串”abcdef”,那么只要：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">10</span>];  </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);  </span><br></pre></td></tr></table></figure>
<p><strong>说明：scanf函数读入字符串时，是以空格、制表符及回车作为不同字符串之间的分隔符的；</strong><br>2、字符串中含有空格、制表符，但不含回车,对于这种情况不能使用scanf,而应该使用gets函数；<br>例如：要读入字符串 “Hello world!”,那么只要：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line">gets(str);</span><br></pre></td></tr></table></figure>
<p><strong>说明：gets函数读入字符串时，只以回车作为不同字符串之间的分隔符；另外，如果要用gets读入多个字符串，可以写成 while(gets(str)){……}</strong><br>3、字符串中含回车<br>在这种情况下，如果没有题目的说明，程序无法知道哪里是字符串的分界。那么，用scanf(“%c”,&amp;ch)来读，一边读，一边判断分界条件是否满足，如果满足，则把当前读到的东西存到一个字符串中。  </p>
<h2 id="三、输出处理"><a href="#三、输出处理" class="headerlink" title="三、输出处理"></a>三、输出处理</h2><p><strong>一般来讲，输出处理一般只有两个问题：空行打印问题与浮点数的精度问题；</strong>  </p>
<h3 id="关于空行（Blank-line）"><a href="#关于空行（Blank-line）" class="headerlink" title="关于空行（Blank line）"></a>关于空行（Blank line）</h3><p>很多题目都要求在输出数据的恰当位置加空行。一个空行就是一个单独的”\n”。这里，有的题目说：“After each test case, you should output one blank line”，而有的题目说：“Between each test case, you should ouput one blank line”。要注意After和Between的区别，因为如果多了一或少了空行，将导致Presentation Error甚至Wrong Answer。<br>（1）After<br>这种情况最简单，只需要输出结果后，再加一个printf(“\n”);<br>示例：<a href="http://acm.njupt.edu.cn/acmhome/problemdetail.do?&method=showdetail&id=1087">A + B Problem (4)</a><br>C语言：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,sum,a;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n) &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">         sum=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span>(n--)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">             sum+=a;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++：  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,sum,a;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&amp;&amp;n)</span><br><span class="line">    &#123;</span><br><span class="line">         sum=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span>(n--)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">             sum+=a;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">         <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）Between<br>Between和After不同的是，最后一组结果后面不应该再加单独的”\n”，应该像这样：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">9</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于有时候我们并不知道测试数据有几组（比如测试数据是以end of file 结束的），用上面的方法就不行了，于是，可以换一种写法：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">bool</span> first = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a) == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!first)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        first = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，从第二组测试数据起，在输出每组测试数据的结果之前就会输出一个空行，和想要的效果是一样的。  </p>
<h3 id="关于精度"><a href="#关于精度" class="headerlink" title="关于精度"></a>关于精度</h3><p>(1)结果保留x位小数<br>这种比较简单，只要 printf(“%.xf\n”,ans);  即可。例如，要求保留6位小数: printf(“%.6f\n”,ans);<br>(2)没有说明要求保留几位，但要求与结果的误差不大于1e-x;<br>解决 : printf(“%.(x+3)f\n”,ans);<br>例如：要求与结果的误差不大于1e-9 : printf(“%.12f\n”,ans);  </p>
<p>声明：本文转载自南京邮电大学online jude平台<br>Alisa 转载于 江苏 苏州<br>2017.06.03</p>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构专题（1）——绪论</title>
    <url>/2017/08/01/2017-08-02-sjjg01/</url>
    <content><![CDATA[<ul>
<li>content<br>{:toc}</li>
</ul>
<h1 id="一、数据结构学习方法"><a href="#一、数据结构学习方法" class="headerlink" title="一、数据结构学习方法"></a>一、数据结构学习方法</h1><ul>
<li>理解各种数据结构的逻辑特性和存储结构设计  </li>
<li>掌握各种数据结构算法设计的基本方法  </li>
<li>利用各种数据结构来求解实际问题  </li>
<li>演绎和归纳相结合  <h1 id="二、数据结构的定义"><a href="#二、数据结构的定义" class="headerlink" title="二、数据结构的定义"></a>二、数据结构的定义</h1><h2 id="数据结构中的几个概念"><a href="#数据结构中的几个概念" class="headerlink" title="数据结构中的几个概念"></a>数据结构中的几个概念</h2></li>
<li>数据：所有能够输入到计算机中，且能被计算机处理的符号的集合。  </li>
<li>数据元素：是数据（集合）中的一个“个体”，它是数据的基本单位。  </li>
<li>数据项：数据项是用来描述数据元素的，它是数据的最小单位。  </li>
<li>数据对象：具有<strong>相同性质</strong>的若干个数据元素的集合，如整数数据对象是所有整数的集合。<br>默认情况下，数据结构中讨论的数据都是数据对象。  </li>
<li>数据结构：是指<strong>带结构</strong>的数据元素的集合。  <h1 id="三、数据的结构表示"><a href="#三、数据的结构表示" class="headerlink" title="三、数据的结构表示"></a>三、数据的结构表示</h1><h2 id="数据的逻辑结构表示"><a href="#数据的逻辑结构表示" class="headerlink" title="数据的逻辑结构表示"></a>数据的逻辑结构表示</h2>表示形式有：表格、二元组、图形。  <h2 id="数据的存储结构表示"><a href="#数据的存储结构表示" class="headerlink" title="数据的存储结构表示"></a>数据的存储结构表示</h2><h3 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h3>【例】存放学生表的结构体数组Stud定义如下：  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> no;</span><br><span class="line">  chasr name[<span class="number">8</span>];</span><br><span class="line">  <span class="keyword">char</span> sex[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">char</span> <span class="class"><span class="keyword">class</span>[4];</span></span><br><span class="line">&#125;Stud[<span class="number">7</span>]=&#123;&#123;<span class="number">1</span>,<span class="string">&quot;zhangsan&quot;</span>,man,<span class="string">&quot;9901&quot;</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
特点：所有元素占用一整块内存空间；逻辑上相邻的元素，物理上也相邻。（顺序存储结构）  <h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3>【例】存放学生表的链表的节点类型StudType声明如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">studnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> no;</span><br><span class="line">  chasr name[<span class="number">8</span>];</span><br><span class="line">  <span class="keyword">char</span> sex[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">char</span> <span class="class"><span class="keyword">class</span>[4];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">studnode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;StudType;</span><br></pre></td></tr></table></figure>
特点：一个逻辑元素用一个节点存储，每个节点单独分配，所有节点的地址不一定是连续的。用指针来表示逻辑关系。（链式存储结构）  <h1 id="四、算法"><a href="#四、算法" class="headerlink" title="四、算法"></a>四、算法</h1><h2 id="算法的5个重要特性："><a href="#算法的5个重要特性：" class="headerlink" title="算法的5个重要特性："></a>算法的5个重要特性：</h2>有穷性、确定性、可行性、有输入、有输出  <h2 id="输出型参数："><a href="#输出型参数：" class="headerlink" title="输出型参数："></a>输出型参数：</h2>在C++语言中提供了一种<strong>引用</strong>运算符“&amp;”用于描述输出型参数。<br>【例】交换两个整数的算法：  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp = x;</span><br><span class="line">  x = y;</span><br><span class="line">  y = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="算法分析基础"><a href="#算法分析基础" class="headerlink" title="算法分析基础"></a>算法分析基础</h2><h3 id="算法时间复杂度分析"><a href="#算法时间复杂度分析" class="headerlink" title="算法时间复杂度分析"></a>算法时间复杂度分析</h3>分析算法的执行时间：  </li>
<li>求出算法所有原操作的执行次数（频度），它是<strong>问题规模n</strong>的函数，用T(n)表示</li>
<li>算法执行时间大致 = 原操作所需要的时间xT(n)。所以T（n）与算法执行时间成正比，为此用T（n）表示算法的执行时间  </li>
<li>比较不同算法的T(n)大小得出算法执行时间的好坏。<br>算法的执行时间用时间复杂度来表示：<br>T(n)=O(f(n))<br>常见时间复杂度：  </li>
<li>一个没有循环的算法的执行时间与问题规模n无关，记作O(1)，也称作<strong>常数阶</strong>  </li>
<li>一个只有一重循环的算法的执行时间与问题规模n的增长呈线性增大关系，记作O(n)，也称<strong>线性阶</strong>  </li>
<li>其余常用时间复杂度还有<strong>平方阶</strong>O(n^2),<strong>立方阶</strong>O(n^3)<strong>对数阶</strong>O(log n),<strong>指数阶</strong>O(2^n)等。<br>各种不同算法时间复杂度的大小关系如下：<br><img src="https://raw.githubusercontent.com/Katherine001/markdowm-photo/master/photo/sjjg1.PNG"><br>算法的空间复杂度分析：<br>定义：用于量度一个算法在运行过程中<strong>临时占用的存储空间大小</strong>，一般也作为问题规模n的函数，记作：S(n)=O(g(n))<br>若一个算法的空间复杂度为O(1)，则称此算法为<strong>原地工作</strong>或<strong>就地工作</strong>算法。  <h1 id="五、例题选讲"><a href="#五、例题选讲" class="headerlink" title="五、例题选讲"></a>五、例题选讲</h1>【例1】求两个n阶方阵的相加C=A+B的算法如下，分析时间复杂度：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 20  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">matrixadd</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> A[MAX][MAX],<span class="keyword">int</span> B[MAX][MAX],<span class="keyword">int</span> C[MAX][MAX])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i,j;</span><br><span class="line">  <span class="keyword">for</span>( i = <span class="number">0</span>;i &lt; n;i ++ )</span><br><span class="line">  	<span class="keyword">for</span>( j = <span class="number">0</span>;j &lt; n;j ++ )</span><br><span class="line">  		C[i][j] = A[i][j] + B[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://raw.githubusercontent.com/Katherine001/markdowm-photo/master/photo/sjjg2.PNG"><br>【例2】分析以下算法的空间复杂度:  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i,j,k,s;</span><br><span class="line">  s = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt;= n;i ++)</span><br><span class="line">  	<span class="keyword">for</span>(j = <span class="number">0</span>;j &lt;= i;j ++)</span><br><span class="line">  		<span class="keyword">for</span>(k = <span class="number">0</span>;k &lt;= j;k ++)</span><br><span class="line">  			s++;</span><br><span class="line">  <span class="keyword">return</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
【解】：算法中临时分配的变量个数与问题规模n无关，所以空间复杂度均为O(1)<br>【例3】分析下面算法的时间复杂度，并给出必要过程  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">0</span>,s=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(s&lt; n)</span><br><span class="line">  &#123;</span><br><span class="line">    i++;</span><br><span class="line">    s+=i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
该题目留作作业，答案下期公布<br>数据结构专题每周更新2期，敬请关注！<br>Alisa写于江苏省苏州市 2017.08.02</li>
</ul>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>新博客</title>
    <url>/2017/08/03/2017-08-04-newblog/</url>
    <content><![CDATA[<ul>
<li>content<br>{:toc}</li>
</ul>
<p>今天下午花了两个小时重新给博客换了新面貌，新的博客相比原来的博客主题，显得更加简洁，主要采用纯色调，没有那么多花里胡哨的图片。在使用原来的主题时，由于强迫症，每次写博文都要花时间找配图，现在完全没有这个问题了。新的博客主题下，博文的排版格式也是相对于以前的主题，我比较喜欢的部分。我选择这一款主题，也是比较了很多的主题后仔细考虑定夺下来的，选择这样的主题，是希望我的博客能使读者更加关注博文本身的内容。现在我的水平有限还不能有把握地自己原创出一套主题来，但是我相信那一天总会到来，我也能够自己玩出自己的风格。<br>在接下来的日子，我尽量会把发布博文的频率提高一些，将自己所学的，以及计算机专业重要学科的基础知识及时进行归纳总结，开学就要大三了，也要开始准备考研了，同样和考研有关的一些知识整理也会总结在我的博文里，希望同道中人能给予指点，有错误的地方欢迎给我发送邮件，邮箱：<a href="mailto:&#x61;&#x6c;&#105;&#x73;&#97;&#108;&#x6a;&#110;&#x40;&#x31;&#50;&#x36;&#x2e;&#x63;&#111;&#109;">&#x61;&#x6c;&#105;&#x73;&#97;&#108;&#x6a;&#110;&#x40;&#x31;&#50;&#x36;&#x2e;&#x63;&#111;&#109;</a>，愿我们共同进步。<br>Alisa写于江苏省苏州市<br>2017.08.04</p>
]]></content>
      <categories>
        <category>Random thoughts</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言指针练习</title>
    <url>/2017/08/25/2017-08-26-ex/</url>
    <content><![CDATA[<ul>
<li>content<br>{:toc}</li>
</ul>
<p>C语言指针部分练习精选下载链接：<br><a href="https://github.com/Katherine001/markdowm-photo/raw/master/%E6%8C%87%20%20%E9%92%88%20%20%E7%BB%83%E4%B9%A0%E9%A2%98.docx">点此下载</a></p>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>开学啦</title>
    <url>/2017/09/03/2017-09-04-kx/</url>
    <content><![CDATA[<ul>
<li>content<br>{:toc}</li>
</ul>
<p>暑假一晃而过，转眼又开学了。这个暑假个人觉得还算充实，去了一趟广州旅游，领略了广式茶点的美妙，欣赏了广州的建筑，图书馆，大剧院，科学馆这些建筑各有特色，尤其在晚上，灯光的效果下，在熙熙攘攘的人群中更是为广州这座繁华增加了些许科技之美感。广州的交通系统也是非常发达，地铁几乎能到达任何想去的地方，街边的共享单车也是数量庞大，真正满足了人们的出行之便利。不愧是大都市！<br>开学迈入了大三的学习，课表上的课也全换成了专业课，每一门课都需要我去认真钻研体会，或许这样我才能更加确切的选择我的心中理想的研究路线。身边不少同学开始准备考教师资格证，考研等等，我觉得这才是我们年轻人该做的事情，趁早选择好自己要走的道路，尽情地挥洒汗水，回报总会有的。虽然我们每个人都很平凡，但是人总想突破自己，使自己变得不平凡，这或许就是青春的意义吧。<br>在这里要特别感谢一下我的研友樱薇，很高兴在这所大学遇见了志同道合的你，我希望在今后的学习道路上能够一直与你同行！<br>——Alisa写于江苏泰州<br>2017.09.04</p>
]]></content>
      <categories>
        <category>Random thoughts</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>串比较运算</title>
    <url>/2017/09/04/2017-09-05-sjjg/</url>
    <content><![CDATA[<ul>
<li>content<br>{:toc}</li>
</ul>
<h1 id="设计顺序串上实现串比较运算Strcmp-s-t-的算法"><a href="#设计顺序串上实现串比较运算Strcmp-s-t-的算法" class="headerlink" title="设计顺序串上实现串比较运算Strcmp(s,t)的算法"></a>设计顺序串上实现串比较运算Strcmp(s,t)的算法</h1><h2 id="分析"><a href="#分析" class="headerlink" title="[分析]"></a>[分析]</h2><h3 id="算法思路如下："><a href="#算法思路如下：" class="headerlink" title="算法思路如下："></a>算法思路如下：</h3><p>（1）比较s和t两个串的<strong>共同长度范围</strong>内的对应字符<br>Ⅰ.若s的字符&gt;t的字符，返回1<br>Ⅱ.若s的字符&lt;t的字符，返回-1<br>Ⅲ.若s的字符=t的字符，按上述规则继续比较<br>（2）当（1）中对应字符均相同时，比较s和t的长度<br>Ⅰ.两者相等时，返回 0<br>Ⅱ.s长度&gt;t长度，返回1<br>Ⅲ.s长度&lt;t长度，返回-1  </p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="[算法实现]"></a>[算法实现]</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Strcmp</span><span class="params">(SqString s,SqString t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i,comlen;</span><br><span class="line">  <span class="keyword">if</span>(s.length&lt;t.length) comlen=s.length;<span class="comment">//求s和t的共同长度</span></span><br><span class="line">  <span class="keyword">else</span> comlen=t.length;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;comlen;i++)<span class="comment">//在共同长度内逐个字符比较</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(s.data[i]&gt;t.data[i])  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s.data[i]&lt;t.data[i]) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(s.length==t.length) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//s==t</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(s.length&gt;t.length)  <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//s&gt;t</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//s&lt;t</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>——Alisa写于江苏泰州<br>2017.09.05</p>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>2018第一篇博客--一点感想</title>
    <url>/2018/01/24/2018-01-25-yi/</url>
    <content><![CDATA[<ul>
<li>content<br>{:toc}</li>
</ul>
<p>寒假过了十来天，到了第五天左右的时间，也把自己从散漫的状态调整了过来，从期末考试考完结束放肆状态到规律的生活也不是一下功夫能适应的。在刚刚过去的一学期，觉得自己也算是很浪了吧，本身对于学校所开设的课程不大满意，觉得很多课程没有学的必要，不应该是CS的重点，而一些重点课程学校反而没有足够重视甚至舍去一些重点科目，用类似于ps这种课程取代了专业课的位置，在得知期末考试针对每门课都要进行笔试考核的时候我彻底慌了——真的是0基础啊，在半个星期的时间我突破了8门课，最终成绩下来的时候还是挂了一门纯背书的课，这让我一度感觉十分羞耻，但是想想也是自己活该，<del>谁让我这么浪呢（虽然还是充满了对那个老师的愤懑）</del>，毕竟学习生活还是要往前看的，下学期的课程现在也排了出来，选修课也选了两门自认为比较有用的课程，今年的十二月份我也将踏上研究生考试的考场，对于接下来寒假的日子，我也准备每天花时间在公共课数学和英语上，下个学期不出意外的时候也是在自习室图书馆度过了，过几天我也会为自己列一份考研复习期间的日程表，这份表格也应该是我认为适合自己的，而不是参考别人的计划，但是我也愿意把它分享给同道中人参考。对于考研这件事情，我信心还是比较充足的，在这两天的复习中，我也陆陆续续捡起了大一时的高数基础知识，也逐渐感受到了高三日日夜夜刷题的感觉，其实对于我们本身来说，要想做好这件事情，应该调整心态去享受它，虽然没有人会觉得考研过程是一件有意思的事情，但是我们应该发挥自己的主观能动性，同样做事情我们肯定希望以一种轻松的方式（心态上放松而不是行动上放松），必然会取得自己理想的成果。也会是自己的一段难忘的经历。<br>在这一年里，我也会继续保持博客的更新（可能频率会比较低，一个月2—3次吧），主要还是以随笔，生活感想体会也好，一闪而过的灵感也好，预祝自己今年能一帆风顺吧，也预祝读者们能够在2018年与自己心中的理想更近一步吧，谢谢！<br>——Alisa写于江苏苏州<br>2018年1月25日晚9点</p>
]]></content>
      <categories>
        <category>Random thoughts</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>写在2019的第一篇blog</title>
    <url>/2019/01/13/2019-01-14-gh/</url>
    <content><![CDATA[<ul>
<li>content<br>{:toc}</li>
</ul>
<h1 id="回顾2018"><a href="#回顾2018" class="headerlink" title="回顾2018"></a>回顾2018</h1><h2 id="一、学业"><a href="#一、学业" class="headerlink" title="一、学业"></a>一、学业</h2><p>这一年的学业，似乎没有什么大的突破，4月初参加了第九届蓝桥杯程序设计竞赛，依旧是一个很弱鸡的省三。去年同我一同参加的拿了省三的小伙伴此次晋级了国赛，看着他去北京参加决赛或多或少自己也是有些自责的，不过也替他感到高兴，毕竟一分耕耘一分收获，是我自己偷懒了没有下足功夫。  </p>
<p>大三下学期，成绩依旧稳定在班级前五，如愿拿了滚动二等奖学金，也算比之前每年的三等奖学金稍微好看点了。  </p>
<p>暑假的时候开始准备2019研究生入学考试，可惜的是由于自己的身体问题没有坚持下去，现在想来自己不应该放弃的。  </p>
<p>11月的时候开始自学Java开发岗的知识，每天看看视频敲敲代码，日子过得也是很惬意的。  </p>
<h2 id="二、生活"><a href="#二、生活" class="headerlink" title="二、生活"></a>二、生活</h2><p>平平淡淡，庸庸碌碌，这八个字可以概括我2018年的生活了。  </p>
<h1 id="规划2019"><a href="#规划2019" class="headerlink" title="规划2019"></a>规划2019</h1><p>这一年，注定是我人生中不平凡的一年，面临着毕业实习，毕业设计，考研等众多事物，其他的也不多说，在这里先立一些flag，等到年底的时候再来看看自己完成了哪些。  </p>
<ul>
<li>找到一份满意的实习，能够尽可能多积累一些项目经验</li>
<li>完善自己的Java开发技术栈</li>
<li>毕业设计拿到优秀评价</li>
<li>充分准备2020考研初试</li>
<li>拿到驾照</li>
<li>学会做一些家常菜</li>
<li>找到自己的另一半</li>
</ul>
<p>最后，想和各位分享一句话：  </p>
<p><strong><em>种一棵树的最好时间是十年前，其次是现在</em></strong>  </p>
<p>愿我们能够珍惜当下时光，好好把握！  </p>
<p><strong>Alisa写于   2019/01/14    江苏南京</strong></p>
<p>​        </p>
]]></content>
      <categories>
        <category>Random thoughts</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>C#学习过程中踩的大大小小的坑（持续更新）</title>
    <url>/2019/01/15/2019-01-16-Csharptt/</url>
    <content><![CDATA[<ul>
<li>content<br>{:toc}<h2 id="前言：原本以为自身有了java和C的基础，学习C-的基础语法时，应该是很顺手的，实际开始学习了才发现各个语言中的细节部分是有所差异的。现将这些需要注意的坑汇总如下，随着我的学习会不断更新："><a href="#前言：原本以为自身有了java和C的基础，学习C-的基础语法时，应该是很顺手的，实际开始学习了才发现各个语言中的细节部分是有所差异的。现将这些需要注意的坑汇总如下，随着我的学习会不断更新：" class="headerlink" title="前言：原本以为自身有了java和C的基础，学习C#的基础语法时，应该是很顺手的，实际开始学习了才发现各个语言中的细节部分是有所差异的。现将这些需要注意的坑汇总如下，随着我的学习会不断更新："></a><strong><em>前言：原本以为自身有了java和C的基础，学习C#的基础语法时，应该是很顺手的，实际开始学习了才发现各个语言中的细节部分是有所差异的。现将这些需要注意的坑汇总如下，随着我的学习会不断更新：</em></strong></h2></li>
</ul>
<h3 id="1-Form-Load-方法不被执行"><a href="#1-Form-Load-方法不被执行" class="headerlink" title="1.Form_Load()方法不被执行"></a>1.Form_Load()方法不被执行</h3><p>在写迷你计算器的案例的时候，有个需求需要将界面中的ComboBox控件（显示运算符的）默认显示“+”号，在学习的过程中看见参考源码中采用了Form_Load方法，具体形式如下：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Form1_Load_1</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cboCaoZuoFu.SelectedIndex = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我在Form1.cs中手动添加该方法，然后运行发现该方法的操作并不会生效，查阅资料后发现有三种解决方案：</p>
<h4 id="方案一（推荐）："><a href="#方案一（推荐）：" class="headerlink" title="方案一（推荐）："></a>方案一（推荐）：</h4><p>删除这个方法，然后到设计界面那里，**双击界面后，会发现自动生成了Form1_load()**，然后再进行代码编写。</p>
<h4 id="方案二："><a href="#方案二：" class="headerlink" title="方案二："></a>方案二：</h4><p>在构造方法Form1中添加一句语句：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.Load += <span class="keyword">new</span> EventHandler(Form1_Load);</span><br></pre></td></tr></table></figure>
<p>该方法即调整为：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Form1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InitializeComponent();</span><br><span class="line">    <span class="keyword">this</span>.Load += <span class="keyword">new</span> EventHandler(Form1_Load);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方案三："><a href="#方案三：" class="headerlink" title="方案三："></a>方案三：</h4><p>将Form_Load()中需要写的代码<strong>直接添加到Form1()方法中</strong>。  </p>
<p>即：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Form1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InitializeComponent();</span><br><span class="line">    cboCaoZuoFu.SelectedIndex = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-switch语句"><a href="#2-switch语句" class="headerlink" title="2.switch语句"></a>2.switch语句</h3><p>在C#的语法规范中，switch语句块的每个case后面必须跟有一个break，如这种写法：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">switch</span> (op)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">     	语句块;</span><br><span class="line">     <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">        语句块;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法在java中可能不会报错，<strong>但是在C#中是不被允许的</strong>，应该改成这样：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">switch</span> (op)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">     	语句块;</span><br><span class="line">     	<span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">        语句块;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>事实上这本应该是我们编码需要注意的，不然可能会产生我们不愿意看到的场景。</strong>  </p>
<p><strong>（未完待续）</strong></p>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>C#学习笔记-Day1</title>
    <url>/2019/01/16/2019-01-17-dotNet1/</url>
    <content><![CDATA[<ul>
<li>content<br>{:toc}<h1 id="一、-net程序基本编写、执行流程"><a href="#一、-net程序基本编写、执行流程" class="headerlink" title="一、.net程序基本编写、执行流程"></a>一、.net程序基本编写、执行流程</h1></li>
</ul>
<ul>
<li>编写C#代码，保存为.cs文件</li>
<li>通过csc.exe程序来将.cs文件编译为.net程序集（.exe或者.dll）。此时的exe或dll并不是机器码（cpu不可理解）。</li>
<li>程序运行时通过JIT（Just In Time）即时编译，将程序集编译为cpu能理解的机器码，这是cpu才能执行。（这个编译过程会和当前机器有关（根据当前机器的内存和cpu等））。  </li>
</ul>
<h1 id="二、面向对象思想"><a href="#二、面向对象思想" class="headerlink" title="二、面向对象思想"></a>二、面向对象思想</h1><p><strong><em>说明：由于之前已经学习过C、Java等高级语言，因此C#基本语法部分此笔记不再涉及。</em></strong></p>
<h2 id="（一）几个专用名词"><a href="#（一）几个专用名词" class="headerlink" title="（一）几个专用名词"></a>（一）几个专用名词</h2><p>OOP：Object-Oriented Programming  </p>
<p>OOA：面向对象分析（Analysis）  </p>
<p>OOD：面向对象设计（Design）</p>
<p>OOAD：面向对象分析与设计  </p>
<h2 id="（二）面向对象三大特性"><a href="#（二）面向对象三大特性" class="headerlink" title="（二）面向对象三大特性"></a>（二）面向对象三大特性</h2><p>封装  </p>
<p>继承  </p>
<p>多态  </p>
<h2 id="（三）类、对象"><a href="#（三）类、对象" class="headerlink" title="（三）类、对象"></a>（三）类、对象</h2><h3 id="1-什么是类"><a href="#1-什么是类" class="headerlink" title="1.什么是类"></a>1.什么是类</h3><p>类是模具，创建对象的模具，<strong>抽象的</strong>：</p>
<ul>
<li>类是一种数据类型，用户自定义的数据类型</li>
<li>类组成：<ul>
<li><strong>字段</strong></li>
<li><strong>属性</strong></li>
<li><strong>方法</strong></li>
<li><strong>构造函数</strong></li>
<li>……</li>
</ul>
</li>
</ul>
<h3 id="2-什么是对象"><a href="#2-什么是对象" class="headerlink" title="2.什么是对象"></a>2.什么是对象</h3><p>对象是具体的，是类的具体实例。对象具有<strong>属性</strong>（特征）和<strong>方法</strong>（行为）</p>
<h3 id="3-this关键字"><a href="#3-this关键字" class="headerlink" title="3.this关键字"></a>3.this关键字</h3><p>代表当前对象</p>
<h3 id="4-案例：老师、学生类"><a href="#4-案例：老师、学生类" class="headerlink" title="4.案例：老师、学生类"></a>4.案例：老师、学生类</h3><h4 id="（1）写学生类"><a href="#（1）写学生类" class="headerlink" title="（1）写学生类:"></a>（1）写学生类:</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义好一个类后，不写构造函数会有一个默认的无参构造函数</span></span><br><span class="line">    <span class="comment">//添加构造函数，当为类手动编写一个构造函数后，会覆盖默认的那个构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span>(<span class="params"><span class="built_in">string</span> name,<span class="built_in">int</span> age,<span class="built_in">string</span> gender,<span class="built_in">string</span> sid</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Name = name;</span><br><span class="line">        <span class="keyword">this</span>.Age = age;</span><br><span class="line">        <span class="keyword">this</span>.Gender = gender;</span><br><span class="line">        <span class="keyword">this</span>.Sid = sid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> gender;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> sid;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>&#123;<span class="keyword">return</span> name;&#125;</span><br><span class="line">        <span class="keyword">set</span>&#123;name = <span class="keyword">value</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>&#123;<span class="keyword">return</span> age;&#125;</span><br><span class="line">        <span class="keyword">set</span>&#123;age = <span class="keyword">value</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Gender</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>&#123;<span class="keyword">return</span> gender;&#125;</span><br><span class="line">        <span class="keyword">set</span>&#123;gender = <span class="keyword">value</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Sid</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">get</span>&#123;<span class="keyword">return</span> sid;&#125;</span><br><span class="line">       <span class="keyword">set</span>&#123;sid = <span class="keyword">value</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（2）写教师类"><a href="#（2）写教师类" class="headerlink" title="（2）写教师类"></a>（2）写教师类</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Teacher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>&#123;<span class="keyword">return</span> name;&#125;</span><br><span class="line">        <span class="keyword">set</span>&#123;name = <span class="keyword">value</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayHello</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（3）写测试类"><a href="#（3）写测试类" class="headerlink" title="（3）写测试类"></a>（3）写测试类</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Teacher tea = <span class="keyword">new</span> Teacher(<span class="string">&quot;小米&quot;</span>);</span><br><span class="line">        Student stu = <span class="keyword">new</span> Student(<span class="string">&quot;Allen&quot;</span>,<span class="number">15</span>,<span class="string">&quot;男&quot;</span>,<span class="string">&quot;1001&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-案例：迷你计算器"><a href="#5-案例：迷你计算器" class="headerlink" title="5.案例：迷你计算器"></a>5.案例：迷你计算器</h3><h4 id="（1）定义计算器类"><a href="#（1）定义计算器类" class="headerlink" title="（1）定义计算器类"></a>（1）定义计算器类</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">namespace 迷你计算器</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Calculator</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Calculator</span>(<span class="params"><span class="built_in">double</span> d1,<span class="built_in">double</span> d2</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">this</span>.Number1 = d1;</span><br><span class="line">            <span class="keyword">this</span>.Number2 = d2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">double</span> Number1</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span>;</span><br><span class="line">            <span class="keyword">set</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">double</span> Number2</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span>;</span><br><span class="line">            <span class="keyword">set</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">Add</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">return</span> Number1 + Number2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//减法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">Cut</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">return</span> Number1 - Number2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//乘法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">Mul</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">return</span> Number1 * Number2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//除法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">Div</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">return</span> Number1 / Number2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（2）写窗口类"><a href="#（2）写窗口类" class="headerlink" title="（2）写窗口类"></a>（2）写窗口类</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">namespace 迷你计算器</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Form1</span> : <span class="title">Form</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Form1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">comboBox1_SelectedIndexChanged</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Form1_Load_1</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            cboCaoZuoFu.SelectedIndex = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btnJiSuan_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="built_in">int</span> num1 = <span class="built_in">int</span>.Parse(txtNum1.Text.Trim());</span><br><span class="line">            <span class="built_in">int</span> num2 = Convert.ToInt32(txtNum2.Text.Trim());</span><br><span class="line">            Calculator calculator = <span class="keyword">new</span> Calculator(num1,num2);</span><br><span class="line">            <span class="keyword">switch</span> (cboCaoZuoFu.Text.Trim())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                    lblResult.Text = calculator.Add().ToString();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                    lblResult.Text = calculator.Cut().ToString();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                    lblResult.Text = calculator.Mul().ToString();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                    lblResult.Text = calculator.Div().ToString();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="literal">default</span>:</span><br><span class="line">                    lblResult.Text = <span class="string">&quot;未知结果&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（3）写主方法"><a href="#（3）写主方法" class="headerlink" title="（3）写主方法"></a>（3）写主方法</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">namespace 迷你计算器</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 应用程序的主入口点。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        [<span class="meta">STAThread</span>]</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Application.EnableVisualStyles();</span><br><span class="line">            Application.SetCompatibleTextRenderingDefault(<span class="literal">false</span>);</span><br><span class="line">            Application.Run(<span class="keyword">new</span> Form1());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-案例：猜拳游戏"><a href="#6-案例：猜拳游戏" class="headerlink" title="6.案例：猜拳游戏"></a>6.案例：猜拳游戏</h3><p><strong>需求：用户在界面上点击相应的按钮选择出拳，电脑随机产生出拳，然后判定结果并显示在屏幕上</strong></p>
<h4 id="（1）定义玩家类"><a href="#（1）定义玩家类" class="headerlink" title="（1）定义玩家类"></a>（1）定义玩家类</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">namespace 猜拳游戏</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">User</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> FistName</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span>;</span><br><span class="line">            <span class="keyword">set</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//玩家的出拳方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">showFist</span>(<span class="params"><span class="built_in">string</span> fist</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">this</span>.FistName = fist;</span><br><span class="line">            <span class="built_in">int</span> result = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">switch</span>(fist)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;石头&quot;</span>:</span><br><span class="line">                    result = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;剪刀&quot;</span>:</span><br><span class="line">                    result = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;布&quot;</span>:</span><br><span class="line">                    result = <span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（2）定义电脑玩家类"><a href="#（2）定义电脑玩家类" class="headerlink" title="（2）定义电脑玩家类"></a>（2）定义电脑玩家类</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">namespace 猜拳游戏</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Computer</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//用来保存计算机出拳结果的属性</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> FistName</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span>;</span><br><span class="line">            <span class="keyword">set</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算机的出拳方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">showFist</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Random random = <span class="keyword">new</span> Random();</span><br><span class="line">            <span class="built_in">int</span> r = random.Next(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">            <span class="comment">//1.石头</span></span><br><span class="line">            <span class="comment">//2.剪刀</span></span><br><span class="line">            <span class="comment">//3.布</span></span><br><span class="line">            <span class="keyword">switch</span>(r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">this</span>.FistName = <span class="string">&quot;石头&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">this</span>.FistName = <span class="string">&quot;剪刀&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    <span class="keyword">this</span>.FistName = <span class="string">&quot;布&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（3）定义裁判类"><a href="#（3）定义裁判类" class="headerlink" title="（3）定义裁判类"></a>（3）定义裁判类</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">namespace 猜拳游戏</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CaiPan</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">isUserWin</span>(<span class="params"><span class="built_in">int</span> user,<span class="built_in">int</span> computer</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">if</span>(user - computer == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;平局&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(user - computer == <span class="number">-1</span> || user-computer == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;用户赢了&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;输了&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（4）定义窗体类"><a href="#（4）定义窗体类" class="headerlink" title="（4）定义窗体类"></a>（4）定义窗体类</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line">namespace 猜拳游戏</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Form1</span> : <span class="title">Form</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Form1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//优化：将三个按钮的事件都绑定在一个函数上</span></span><br><span class="line">        <span class="comment">//sender触发事件的控件，e表示事件相关信息，或者说，sender是事件源，e是与当前事件相关的信息 </span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">button1_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="comment">//把sender显示类型转换为button</span></span><br><span class="line">            Button btn = (Button)sender;</span><br><span class="line">            <span class="keyword">if</span>(btn != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                User u1 = <span class="keyword">new</span> User();</span><br><span class="line">                <span class="built_in">int</span> userFist = u1.showFist(btn.Text);</span><br><span class="line">                labelUser.Text = u1.FistName;</span><br><span class="line">                Computer pc1 = <span class="keyword">new</span> Computer();</span><br><span class="line">                <span class="built_in">int</span> computerFist = pc1.showFist();</span><br><span class="line">                labelPc.Text = pc1.FistName;</span><br><span class="line">                CaiPan cp = <span class="keyword">new</span> CaiPan();</span><br><span class="line">                labelResult.Text = cp.isUserWin(userFist, computerFist);</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="（5）定义主类"><a href="#（5）定义主类" class="headerlink" title="（5）定义主类"></a>（5）定义主类</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line">namespace 猜拳游戏</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 应用程序的主入口点。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        [<span class="meta">STAThread</span>]</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Application.EnableVisualStyles();</span><br><span class="line">            Application.SetCompatibleTextRenderingDefault(<span class="literal">false</span>);</span><br><span class="line">            Application.Run(<span class="keyword">new</span> Form1());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h3><p>通过这些案例，我们进一步理解了：  </p>
<p><strong>1.类的作用</strong>  </p>
<p><strong>2.窗体应用程序设计的思路</strong>  </p>
<p><strong>3.参数sender和e的作用</strong></p>
<p><strong><em>Alisa写于 2019/01/17 江苏苏州</em></strong></p>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】眼里心里的太湖</title>
    <url>/2019/01/22/2019-01-23-par01/</url>
    <content><![CDATA[<ul>
<li>content<br>{:toc}</li>
</ul>
<h2 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h2><table>
  <tr>
    <th><b>作者</b></th>
    <th>Katherine</th>
  </tr>
  <tr>
    <td><b>文章来源</b></td>
    <td>http://sz3z.cn/Item/1280.aspx</td>
  </tr>
</table>



<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>&ensp;&ensp;&ensp;&ensp;坐在车上时，我就迫不及待地掀开窗帘，一心想要重温心中太湖的景色。</p>
<p>&ensp;&ensp;&ensp;&ensp;然而眼里的太湖却并不是那么令人欢喜。</p>
<p>&ensp;&ensp;&ensp;&ensp;灰蒙蒙的天空看不清云丝，绿树掩映下的太湖平静而温婉，远远看去的湖水是苍白的颜色，总觉得少了些色彩。看不到太湖的边界，只是在湖与天交接的地方，看到银白色的地平线，颜色是那么单调而沉暗。</p>
<p>&ensp;&ensp;&ensp;&ensp;下了车，我捧着相机匆匆走上木桥。</p>
<p>&ensp;&ensp;&ensp;&ensp;近处的湖水原来是碧绿的，只是绿得不那么纯粹罢了。我细细地看，却只是看到湖面上积起的绿色水藻和翠色浮萍。它们密密麻麻地分布在纯净的湖水面上，随着微风层层漾开，随后又层层汇聚。一条小木船横在水草里，几个戴着草帽的妇女正佝偻着背，清理那些发疯一般生长的植物。我站在木桥上，看着她们的动作，一阵阵腥腻的味道溢入鼻端，我转头去看那远处的湖水。</p>
<p>&ensp;&ensp;&ensp;&ensp;几艘颜色亮丽的快艇驶入眼帘，疾驰而过，向后喷溅而出的湖水摔回湖里，只是徒增了几分湖水的浑浊，似乎还翻起了不少泥泞。</p>
<p>&ensp;&ensp;&ensp;&ensp;我捧着相机，不知该如何拍下眼里的太湖。</p>
<p>&ensp;&ensp;&ensp;&ensp;带着一丝侥幸，我挪动步伐，朝着远处的大水车走去。一路上见到许许多多的游客，他们都在心安理得地欣赏着太湖的美景，还不停地用闪光灯记录下这里的点点滴滴。水车只是在缓缓转动，像是已经年迈的老者，枯燥乏味地搅动着日益浑浊的湖水。洒下的湖水溅落，孩子们高兴地伸手去接，却被大人们以不干净为由拉回。</p>
<p>&ensp;&ensp;&ensp;&ensp;我的眼前渐渐浮起一层薄薄的雾。</p>
<p>&ensp;&ensp;&ensp;&ensp;昔日，土耳其蓝宝石般的天空飘着淡淡洁白的云丝，太湖并不似如今这般平静深沉，那时它更像是个活泼的小姑娘。白花花的波浪追着鱼群，拍打在蔚蓝的湖面，又溅起白花花的波浪。芦苇生长在湖岸，微风里摇曳着安详和寂静。</p>
<p>&ensp;&ensp;&ensp;&ensp;也曾经见过捕鱼的渔夫，他们扔出一张张大网，过了好些时候，再拿上来时网里已经跳满了白肚皮的鱼，于是渔夫的背都挺得直直的，唱着曲儿回了家。</p>
<p>&ensp;&ensp;&ensp;&ensp;那一幅幅画面，都只能存活在我的心里，而此刻眼里的太湖，无论如何都不能被我的相机所接纳了。如今太湖的富营养化明显，水温升高鱼类减少，这些人们都是知道的——但，为什么不去做些什么，让心里的太湖重新回到我们的眼里呢？</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>我收起相机，望了眼远方，地平线依旧银白，天空也正逐渐蔚蓝。</strong></p>
]]></content>
      <categories>
        <category>Random thoughts</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>2020考研数学备考——网课和辅导书推荐方案</title>
    <url>/2019/01/26/2019-01-27-kysx/</url>
    <content><![CDATA[<ul>
<li>content<br>{:toc}<h1 id="designed-by-Alisa"><a href="#designed-by-Alisa" class="headerlink" title="designed by Alisa"></a><strong>designed by Alisa</strong></h1></li>
</ul>
<p><em>结合<strong>19备考经验、知乎大神</strong>的推荐</em></p>
<p><em>总领：数学备考，<strong>听课5成，练习5成</strong></em></p>
<h2 id="一、教材、参考书准备"><a href="#一、教材、参考书准备" class="headerlink" title="一、教材、参考书准备"></a>一、教材、参考书准备</h2><h3 id="基础阶段（2-6月）"><a href="#基础阶段（2-6月）" class="headerlink" title="基础阶段（2-6月）"></a>基础阶段（2-6月）</h3><p><strong>1.《高等数学（上、下）》同济第七版</strong> <em>（线性代数、概率论课本不用买）</em></p>
<p><strong>2.《李永乐考研数学复习全书（基础篇）》</strong></p>
<p><strong>3.   公式手册</strong></p>
<p><strong>4.《数学基础过关660题》</strong></p>
<h3 id="强化阶段（7-9月）"><a href="#强化阶段（7-9月）" class="headerlink" title="强化阶段（7-9月）"></a>强化阶段（7-9月）</h3><p><strong>5.《汤家凤高等数学辅导讲义》</strong></p>
<p><strong>6《李永乐线性代数辅导讲义》</strong></p>
<p><strong>7.《王式安概率论与数理统计辅导讲义》</strong></p>
<p><strong>8.《数学强化通关330题》</strong></p>
<h3 id="真题阶段（9-10月）"><a href="#真题阶段（9-10月）" class="headerlink" title="真题阶段（9-10月）"></a>真题阶段（9-10月）</h3><p><strong>9.《张宇真题大全解》（质量最好的真题书）</strong></p>
<h3 id="冲刺阶段（11-12月）"><a href="#冲刺阶段（11-12月）" class="headerlink" title="冲刺阶段（11-12月）"></a>冲刺阶段（11-12月）</h3><p><strong>10.《汤家凤绝对考场冲刺八套卷》</strong></p>
<p><strong>11.《李永乐考研数学决胜冲刺6+2》</strong></p>
<p><strong>12.《李永乐考研数学临阵磨枪》</strong></p>
<h2 id="二、各阶段具体复习安排"><a href="#二、各阶段具体复习安排" class="headerlink" title="二、各阶段具体复习安排"></a>二、各阶段具体复习安排</h2><h3 id="基础阶段"><a href="#基础阶段" class="headerlink" title="基础阶段"></a>基础阶段</h3><h4 id="1-网课"><a href="#1-网课" class="headerlink" title="1.网课"></a>1.网课</h4><p><em>（注意：各阶段高数和线代可同步执行，概率论需要等高数学完二重积分以后再开始）</em></p>
<ul>
<li><strong>汤家凤《高等数学教材精讲》</strong>（2-3月）</li>
<li>高昆仑《线性代数教材精讲》（3月）</li>
<li>高昆仑《概率论教材精讲》（3月）</li>
<li><strong>汤家凤《高等数学基础班》</strong>（4-5月）</li>
<li><strong>李永乐《线性代数基础班》</strong>（5月）</li>
<li><strong>王式安《概率论与数理统计基础班》</strong>（6月）</li>
</ul>
<h4 id="2-练习"><a href="#2-练习" class="headerlink" title="2.练习"></a>2.练习</h4><p><em>（注意：练习环节在听完全部教材精讲班后即可开始）</em></p>
<ul>
<li>《考研数学复习全书（基础篇）》全部例题（4-6月）</li>
<li>《数学基础过关660题》全部题目（4-6月）</li>
</ul>
<h3 id="强化阶段"><a href="#强化阶段" class="headerlink" title="强化阶段"></a>强化阶段</h3><h4 id="1-网课-1"><a href="#1-网课-1" class="headerlink" title="1.网课"></a>1.网课</h4><ul>
<li><strong>汤家凤《高等数学强化班》</strong>（7-8月）</li>
<li><strong>李永乐《线性代数强化班》</strong>（7-8月）</li>
<li><strong>王式安《概率论与数理统计强化班》</strong>（7-8月）</li>
</ul>
<h4 id="2-练习-1"><a href="#2-练习-1" class="headerlink" title="2.练习"></a>2.练习</h4><ul>
<li>三本辅导讲义（汤家凤、李永乐、王式安）的所有例题和练习题</li>
<li>《数学强化通关330题》</li>
</ul>
<h3 id="真题阶段"><a href="#真题阶段" class="headerlink" title="真题阶段"></a>真题阶段</h3><h4 id="1-网课-2"><a href="#1-网课-2" class="headerlink" title="1.网课"></a>1.网课</h4><ul>
<li><strong>《高昆仑真题大串讲》</strong></li>
<li>汤家凤真题讲解（公众号）</li>
</ul>
<h4 id="2-练习-2"><a href="#2-练习-2" class="headerlink" title="2.练习"></a>2.练习</h4><ul>
<li>《张宇真题大全解》</li>
<li>基础、强化错题笔记</li>
</ul>
<h3 id="冲刺阶段"><a href="#冲刺阶段" class="headerlink" title="冲刺阶段"></a>冲刺阶段</h3><h4 id="1-网课-3"><a href="#1-网课-3" class="headerlink" title="1.网课"></a>1.网课</h4><ul>
<li><strong>汤家凤《高等数学冲刺班》</strong></li>
<li><strong>李永乐《线性代数冲刺班》</strong></li>
<li><strong>王式安《概率论与数理统计冲刺班》</strong></li>
<li><strong>高昆仑《点睛班》</strong></li>
<li>（选修）李林最后三小时（个人觉得李林的神话不会再续写）</li>
</ul>
<h4 id="2-练习-3"><a href="#2-练习-3" class="headerlink" title="2.练习"></a>2.练习</h4><ul>
<li>错题笔记</li>
<li>《汤家凤绝对考场冲刺八套卷》</li>
<li>《李永乐考研数学决胜冲刺6+2》</li>
</ul>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li>以上所有<strong>加粗课程</strong>为重点课程，需要重点理解</li>
<li>请各位尽可能地支持正版课程</li>
<li>注意<strong>听课练习并重</strong>，不可忽视练习的环节</li>
<li>各阶段注意<strong>错题的整理</strong>，是最后阶段最好的复习资料</li>
</ul>
<h2 id="三、每日安排时间"><a href="#三、每日安排时间" class="headerlink" title="三、每日安排时间"></a>三、每日安排时间</h2><p>基础阶段每日2.5小时（<strong>1.5（听课）+1（做题总结）</strong>）</p>
<p>强化真题阶段每日3.5小时（<strong>1.5（听课）+2（做题总结）</strong>）</p>
<p>冲刺阶段每日3小时（<strong>1（听课）+2（做题总结）</strong>）</p>
<h2 id="四、终极目标"><a href="#四、终极目标" class="headerlink" title="四、终极目标"></a>四、终极目标</h2><h3 id="冲击-150-！！！！！"><a href="#冲击-150-！！！！！" class="headerlink" title="冲击  150  ！！！！！"></a>冲击  150  ！！！！！</h3>]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>浙大数据结构学习笔记——第一章</title>
    <url>/2019/02/01/2019-02-01-sjjg01/</url>
    <content><![CDATA[<ul>
<li>content<br>{:toc}<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1></li>
</ul>
<p>由于本博客站点对数学公式的渲染有问题，因此后续数据结构学习笔记更新在<a href='https://blog.csdn.net/Katherineljn'>我的CSDN博客</a>上。</p>
<h1 id="一、引入"><a href="#一、引入" class="headerlink" title="一、引入"></a>一、引入</h1><h2 id="1-引例1：在书架上摆放图书"><a href="#1-引例1：在书架上摆放图书" class="headerlink" title="1. 引例1：在书架上摆放图书"></a>1. 引例1：在书架上摆放图书</h2><h3 id="方法一：随便放"><a href="#方法一：随便放" class="headerlink" title="方法一：随便放"></a><strong>方法一：</strong>随便放</h3><p><strong>【分析】</strong>考虑：</p>
<ul>
<li><strong>怎么查找</strong>？</li>
</ul>
<p>发现找书非常困难，由此我们优化得到<strong>方法二</strong></p>
<h3 id="方法二：按照书名的拼音字母顺序摆放"><a href="#方法二：按照书名的拼音字母顺序摆放" class="headerlink" title="方法二：按照书名的拼音字母顺序摆放"></a>方法二：按照书名的拼音字母顺序摆放</h3><p><strong>【分析】</strong>考虑：</p>
<ul>
<li>怎么查找？——<strong>二分查找</strong></li>
<li>那怎么插入？</li>
</ul>
<p>若插入的书以字母A打头，<strong>需要将后面大量的书往后移一格</strong>，非常大的操作，<strong>显然这是不合理的</strong></p>
<p><strong>我们需要将自己设身处地，考虑当我们去书店的时候，通常怎么找书呢？</strong></p>
<p>我们往往按照<strong>书的类别</strong>去对应的位置查找，因此我们得到<strong>方法三</strong></p>
<h3 id="方法三：把书架分成几块区域，每个区域指定摆放某种类别的书，在每种类别下按照书名的拼音字母摆放"><a href="#方法三：把书架分成几块区域，每个区域指定摆放某种类别的书，在每种类别下按照书名的拼音字母摆放" class="headerlink" title="方法三：把书架分成几块区域，每个区域指定摆放某种类别的书，在每种类别下按照书名的拼音字母摆放"></a>方法三：把书架分成几块区域，每个区域指定摆放某种类别的书，在每种类别下按照书名的拼音字母摆放</h3><p><strong>【分析】</strong></p>
<ul>
<li>插入新书——先定类别，再二分查找确定新书摆放的位置，移出空位</li>
<li>查找新书——先定类别，再二分查找</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>解决问题方法的效率和<strong>数据的组织形式</strong>有关</p>
<h2 id="2-引例2：写一个函数打印从1-N的全部正整数，N为函数参数"><a href="#2-引例2：写一个函数打印从1-N的全部正整数，N为函数参数" class="headerlink" title="2. 引例2：写一个函数打印从1~N的全部正整数，N为函数参数"></a>2. 引例2：写一个函数打印从1~N的全部正整数，N为函数参数</h2><h3 id="方法一：循环实现"><a href="#方法一：循环实现" class="headerlink" title="方法一：循环实现"></a>方法一：循环实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintN</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>;i &lt;= N;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法二：递归实现"><a href="#方法二：递归实现" class="headerlink" title="方法二：递归实现"></a>方法二：递归实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintN</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(N)</span><br><span class="line">    &#123;</span><br><span class="line">        PrintN(N<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,N);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>经过测试发现递归实现方法在数据较大的情况下会出现溢出</p>
<p>解决问题方法的效率和<strong>空间利用率</strong>有关</p>
<h2 id="3-引例3：计算多项式在给定点x处的值"><a href="#3-引例3：计算多项式在给定点x处的值" class="headerlink" title="3. 引例3：计算多项式在给定点x处的值"></a>3. 引例3：计算多项式在给定点x处的值</h2><p><strong>多项式形式：</strong><br>$$<br>f(x)=a_0+a_1x+a_2x^2+…+a_{n-1}x^{n-1}+a_nx^n<br>$$</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">double</span> a[],<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">double</span> p = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        p+=(a[i] * <span class="built_in">pow</span>(x,i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将这个多项式利用<strong>结合律</strong>，<strong>每次提出一个x</strong>，多项式形式改造为：<br>$$<br>f(x)=a_0+x(a_1+x(a_2+x(…(a_{n-1}+x(a_n))…)))<br>$$</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">double</span> a[],<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">double</span> p = a[n];</span><br><span class="line">    <span class="keyword">for</span>(i = n;i &gt;<span class="number">0</span>;i --)</span><br><span class="line">    &#123;</span><br><span class="line">        p = a[i<span class="number">-1</span>] + x*p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>【补充】</strong></p>
<p>在C语言中，我们可以用<strong>clock()**函数来测试函数的执行时间，首先我们需要在程序开头加上</strong>头文件time.h**,clock()函数返回的时间单位是<strong>clock tick</strong>，即“<strong>时钟打点</strong>“。</p>
<p><strong>常数CLK_TCK</strong>:机器时钟每秒所走的时钟打点数。</p>
<p>定义两个clock_t类型的变量start和stop，start在被测函数前面接收clock函数的返回值，stop在被测函数后面接收clock的返回值。</p>
<p>定义一个double类型的duration来接受stop和start的差，具体如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> duration = ((<span class="keyword">double</span>)(stop-start))/CLK_TCK;</span><br></pre></td></tr></table></figure>
<p>我们可以利用<strong>称纸片质量</strong>的原理（即<strong>多次重复</strong>执行函数）来得到函数运行一次的时间。</p>
<hr>
<p><strong>测试两个方法的效率，发现改造后的多项式效率更高</strong></p>
<h1 id="二、数据结构的相关概念"><a href="#二、数据结构的相关概念" class="headerlink" title="二、数据结构的相关概念"></a>二、数据结构的相关概念</h1><h2 id="1-描述数据对象的组织方式"><a href="#1-描述数据对象的组织方式" class="headerlink" title="1.描述数据对象的组织方式"></a>1.描述数据对象的组织方式</h2><p><strong>逻辑结构</strong>：一般有以下形式：</p>
<ul>
<li>一对一（线性结构）</li>
<li>一对多（树形结构）</li>
<li>多对多（图结构）</li>
</ul>
<p><strong>存储结构</strong>：又称物理存储结构，比如如何存储数据，用数组？还是其它？</p>
<h2 id="2-描述数据结构——抽象数据类型"><a href="#2-描述数据结构——抽象数据类型" class="headerlink" title="2.描述数据结构——抽象数据类型"></a>2.描述数据结构——抽象数据类型</h2><p><strong>数据类型：</strong></p>
<ul>
<li>数据对象集</li>
<li>数据集合相关联的操作集</li>
</ul>
<p><strong>抽象：</strong>描述数据类型的方法不依赖于具体实现</p>
<ul>
<li>与存放数据的机器无关</li>
<li>与数据存储的物理结构无关</li>
<li>与实现操作的算法和编程语言均无关</li>
</ul>
<h2 id="3-例子：矩阵的抽象数据类型定义"><a href="#3-例子：矩阵的抽象数据类型定义" class="headerlink" title="3.例子：矩阵的抽象数据类型定义"></a>3.例子：矩阵的抽象数据类型定义</h2><h3 id="类型名称："><a href="#类型名称：" class="headerlink" title="类型名称："></a>类型名称：</h3><p><strong>矩阵（Matrix）</strong></p>
<h3 id="数据对象集："><a href="#数据对象集：" class="headerlink" title="数据对象集："></a>数据对象集：</h3><p>一个$M<em>N$的矩阵$A_{m</em>n}=(a_{ij})(i=1,…,M;j=1,…,N)$由M*N个三元组&lt;$a,i,j$&gt;构成，其中$a$是矩阵元素的值，$i$是元素所在的行号，$j$是元素所在的列号</p>
<h3 id="操作集："><a href="#操作集：" class="headerlink" title="操作集："></a>操作集：</h3><ul>
<li>*<em>Matrix Create(int M,int N):**返回一个M</em>N的空矩阵</li>
<li>**int GetMaxRow(Matrix A):**返回矩阵A的总行数</li>
<li>……</li>
</ul>
<h1 id="三、算法"><a href="#三、算法" class="headerlink" title="三、算法"></a>三、算法</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p><strong>算法（Algorithm）：</strong></p>
<ul>
<li>一个<strong>有限</strong>的指令集</li>
<li>接受一些<strong>输入</strong>（有些情况下不需要输入）</li>
<li>产生<strong>输出</strong></li>
<li>一定在<strong>有限步骤</strong>后终止</li>
<li>每一条指令必须：<ul>
<li>有<strong>充分明确的目标</strong>，不可以有歧义</li>
<li>计算机能处理的范围之内</li>
<li>描述应当<strong>不依赖于</strong>任何一种计算机语言以及具体实现手段</li>
</ul>
</li>
</ul>
<h2 id="2-例子：选择排序算法的伪代码描述"><a href="#2-例子：选择排序算法的伪代码描述" class="headerlink" title="2.例子：选择排序算法的伪代码描述"></a>2.例子：选择排序算法的伪代码描述</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectionSort</span><span class="params">(<span class="keyword">int</span> List[],<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*将N个整数List[0]...List[N-1]进行非递减排序*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        MinPosition = ScanForMin(List,i,N<span class="number">-1</span>);<span class="comment">//从List[i]到List[N-1]中找最小元，并将其位置赋给MinPosition</span></span><br><span class="line">        Swap(List[i],List[MinPosition]);<span class="comment">//将未排序的部分的最小元换到有序部分的最后的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这段伪代码抽象体现在：</strong></p>
<ul>
<li>List到底是数组还是链表？</li>
<li>Swap用函数还是宏去实现？</li>
</ul>
<p><strong>因此伪代码不关注实现细节</strong></p>
<h2 id="3-算法分析"><a href="#3-算法分析" class="headerlink" title="3.算法分析"></a>3.算法分析</h2><h3 id="3-1-空间复杂度S-n"><a href="#3-1-空间复杂度S-n" class="headerlink" title="3.1 空间复杂度S(n)"></a>3.1 空间复杂度S(n)</h3><p>根据算法写成的程序在执行时<strong>占用的存储单元的长度</strong></p>
<h3 id="3-2-时间复杂度T-n"><a href="#3-2-时间复杂度T-n" class="headerlink" title="3.2 时间复杂度T(n)"></a>3.2 时间复杂度T(n)</h3><p>根据算法写成的程序在执行时<strong>耗费时间的长度</strong></p>
<h3 id="3-3-举例分析"><a href="#3-3-举例分析" class="headerlink" title="3.3 举例分析"></a>3.3 举例分析</h3><h4 id="例1"><a href="#例1" class="headerlink" title="例1."></a>例1.</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintN</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(N)</span><br><span class="line">    &#123;</span><br><span class="line">        PrintN(N<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,N);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>空间复杂度分析：</strong></p>
<p>$S(n)=N*C$</p>
<p>当$N$非常大时，程序就会出现问题</p>
<h4 id="例2"><a href="#例2" class="headerlink" title="例2."></a>例2.</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">double</span> a[],<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">double</span> p = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        p+=(a[i] * <span class="built_in">pow</span>(x,i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度分析：</strong></p>
<p>这个函数做了$1+2+…+n=(n^2+n)/2$次乘法，因此时间复杂度为：<br>$$<br>T(n)=C_1n^2+C_2N<br>$$</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">double</span> a[],<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">double</span> p = a[n];</span><br><span class="line">    <span class="keyword">for</span>(i = n;i &gt;<span class="number">0</span>;i --)</span><br><span class="line">    &#123;</span><br><span class="line">        p = a[i<span class="number">-1</span>] + x*p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度分析：</strong></p>
<p>这个函数做了n次乘法，因此时间复杂度为：<br>$$<br>T(n)=C*n<br>$$</p>
<h3 id="3-4-分析算法的尺度"><a href="#3-4-分析算法的尺度" class="headerlink" title="3.4 分析算法的尺度"></a>3.4 分析算法的尺度</h3><p>在分析一般算法效率的时候，我们经常关注下面两种复杂度：</p>
<ul>
<li>最坏情况复杂度$T_{worst}(n)$</li>
<li>平均复杂度$T_{avg}(n)$</li>
</ul>
<p>很显然有如下关系：<br>$$<br>T_{avg}(n){\leq}T_{worst}(n)<br>$$<br> <strong>我们往往最关心<u>最坏情况复杂度</u></strong></p>
<h3 id="3-5-复杂度的渐进表示法"><a href="#3-5-复杂度的渐进表示法" class="headerlink" title="3.5 复杂度的渐进表示法"></a>3.5 复杂度的渐进表示法</h3><p>$T(n)=O(f(n))$表示存在常数$C&gt;0,n_0&gt;0$使得当$n\geq n_0$时有$T(n)\leq C*f(n)$——<strong>上界</strong></p>
<p>$T(n)=\Omega (g(n))$表示存在常数$C&gt;0,n_0&gt;0$使得当$n\geq n_0$时有$T(n)\geq C*g(n)$——<strong>下界</strong></p>
<p>$T(n)=\Theta(h(n))$表示同时有$T(n)=O(h(n))$和$T(n)=\Omega (h(n))$——<strong>既是上界又是下界</strong></p>
<h3 id="3-6-复杂度分析的小窍门"><a href="#3-6-复杂度分析的小窍门" class="headerlink" title="3.6 复杂度分析的小窍门"></a>3.6 复杂度分析的小窍门</h3><p>(1)若两段算法分别有复杂的$T_1(n)=O(f_1(n))$和$T_2(n)=O(f_2(n))$，则</p>
<ul>
<li>$T_1(n)+T_2(n)=max(O(f_1(n)),O(f_2(n)))$</li>
<li>$T_1(n)*T_2(n)=O(f_1(n)*f_2(n))$</li>
</ul>
<p>(2)若T(n)是关于n的k阶多项式，那么$T(n)=\Theta(n^k)$</p>
<p>(3)一个<strong>for循环</strong>的时间复杂度等于循环次数乘以循环体代码的复杂度</p>
<p>(4)<strong>if-else</strong>结构的复杂度取决于if条件判断复杂度和两个分支部分的复杂度，总体复杂度取三者中最大</p>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>2月学习规划</title>
    <url>/2019/01/31/2019-02-01-xxgh/</url>
    <content><![CDATA[<ul>
<li>content<br>{:toc}<h1 id="一、想说的话"><a href="#一、想说的话" class="headerlink" title="一、想说的话"></a>一、想说的话</h1></li>
</ul>
<p>此时此刻，2019年的2月1日上午11：30，我坐在电脑前，神情恍惚……不知不觉2019年已经过去<strong>十二分之一</strong>了，过去的三个月里，自己学习Java开发，一路摸爬滚打，直到1月中旬和我的一个导师级好友交流后，几乎彻底否定了之前我自己的想法。</p>
<p>简单来说现在学习的后端框架，不在于多么多，而需要把核心放在热门的技术上。并且在学习的过程中，<strong>动手实践应该占整个学习过程的八成以上</strong>，甚至说自己接下来打算实践的项目都需要尽可能地用到这些技术。之前看过一些教程的目录，框架的学习是以SSH（Structs2，Spring，Hibernate）为开场的，然而在自己学习的过程中，<strong>甚至可以直接入手Spring boot这种高效率的框架</strong>，而没有必要再去学习一些老旧的框架。</p>
<p>对于后端程序员，掌握一些前端热门js框架的使用，诸如三大框架（Vue，React，Angular），也是有必要考虑的，毕竟会得多总不是坏事，而且会一些前端的东西，可以做成<strong>前后端分离</strong>，也是目前比较受欢迎的项目结构。</p>
<p>在牛客网自己也读了一些牛人总结的面试经验，大家都非常强调一点——<strong>数据结构和算法</strong>，想想自己也大半年没有去接触算法了，必须得花些功夫在上面了。</p>
<h1 id="二、月度学习规划"><a href="#二、月度学习规划" class="headerlink" title="二、月度学习规划"></a>二、月度学习规划</h1><h2 id="1-后端学习"><a href="#1-后端学习" class="headerlink" title="1.后端学习"></a>1.后端学习</h2><p>由于我毕设选题采用的是微软的Asp.net技术，初步规划做一个前后端分离的博客管理系统，<strong>后端使用Asp.net core Web API，提供数据给前端处理，前端使用Vue.js渲染这些数据</strong>，这个月我的后端学习重心会放在Asp.net core上，并且尽量能在这个月结束之前把博客系统的后端写好。</p>
<h2 id="2-前端学习"><a href="#2-前端学习" class="headerlink" title="2.前端学习"></a>2.前端学习</h2><p>学习使用Vue.js，结合一些新潮的扩展，做一些简单的前端页面出来，比如我现在正在着手做的<strong>考研学习记录</strong>网，主要功能目前构思了两个：</p>
<ul>
<li>考研学习打卡</li>
<li>每日学习时长统计（根据打卡统计）</li>
</ul>
<p>项目完成后我会将该前端的项目技术总结放在这个博客上，代码也会在码云（Gitee）上开源。</p>
<h2 id="3-算法学习"><a href="#3-算法学习" class="headerlink" title="3.算法学习"></a>3.算法学习</h2><p>这一部分也是最近一段时间疏忽下来的，但是确实很重要，诸如BAT等互联网大厂在面试的时候也特别看重程序员的算法功底。</p>
<p>打算这个月每天花两个小时时间在数据结构和算法学习上，每天刷一些算法题。</p>
<p><strong>Alisa写于   2019/02/01    江苏苏州</strong></p>
]]></content>
      <categories>
        <category>Random thoughts</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>长难句第二季笔记</title>
    <url>/2021/01/20/21changnanju/</url>
    <content><![CDATA[<blockquote>
<p>本笔记配套课程为丁晓钟老师的《长难句魔鬼训练营第二季》，该课程同时为《Range·韧迹·看世界》的赠送课程，<a href="https://www.cctalk.com/m/group/89138944?xh_preshareid=37f6d93d-d339-4ec2-abcd-7a6f42cee888&xh_fshareuid=118391021&channel=copy&platform=pc">点击购买与我共同进步</a>~</p>
</blockquote>
<h1 id="第一句"><a href="#第一句" class="headerlink" title="第一句"></a>第一句</h1><p>In laboratories at the Oldham <u>General Hospital</u> in Lancashire and at the University of Cambridge, <u>human eggs</u> have now been successfully brought to maturity, <u>fertilized in vitro</u> and <u>cultured in vitro</u> to the <u>blastocyst</u> stage of development, which is the stage immediately <u>preceding</u> the beginning of normal <u>implantation</u> of the fertilized egg in the <u>uterus</u>. （Scientific American）</p>
<h2 id="【词汇】"><a href="#【词汇】" class="headerlink" title="【词汇】"></a>【词汇】</h2><ul>
<li>General Hospital 综合医院</li>
<li>human eggs 人类卵子</li>
<li>fertilized 受精</li>
<li>in vitro 体外的</li>
<li>culture 培育（细胞）</li>
<li>blastocyst 胚泡</li>
<li>precede 先于</li>
<li>implantation 着床</li>
<li>uterus 子宫</li>
</ul>
<h2 id="【拓展】"><a href="#【拓展】" class="headerlink" title="【拓展】"></a>【拓展】</h2><ul>
<li>scientific name 学名</li>
<li>set a precedent 开创一个先例<br>unprecedented 史无前例的</li>
<li>bring sth. to maturity 使……成熟</li>
<li>【句子填空】<br>The <u>emergence</u> of Bitcoin, a <u>decentralized</u> <u>peer-to-peer</u> digital currency, brought <u>block</u> chain technology to maturity.<ul>
<li>emergence 兴起</li>
<li>decentralized 去中心化的</li>
<li>peer-to-peer 点对点的</li>
<li>block chain 区块链</li>
</ul>
</li>
</ul>
<h1 id="第二句"><a href="#第二句" class="headerlink" title="第二句"></a>第二句</h1><p>Elsewhere, the steep falloff in sales and income taxes — which on average account for roughly two-thirds of a state’s revenue, according to the Pew Charitable Trusts — is forcing Republican and Democratic officials to consider laying off police officers, reducing childhood vaccinations and closing libraries, parks and drug treatment centers.（The New York Times)</p>
<h2 id="【词汇】-1"><a href="#【词汇】-1" class="headerlink" title="【词汇】"></a>【词汇】</h2><h2 id="【拓展】-1"><a href="#【拓展】-1" class="headerlink" title="【拓展】"></a>【拓展】</h2><h1 id="第三句"><a href="#第三句" class="headerlink" title="第三句"></a>第三句</h1><p>Auditors examined the government’s legislation, proposed by Theresa May in 2019 and endorsed by Johnson, to cut greenhouse gases as much as possible and offset remaining pollution by planting trees or using technology to capture carbon over the next 30 years.（The Guardian）</p>
<h2 id="【词汇】-2"><a href="#【词汇】-2" class="headerlink" title="【词汇】"></a>【词汇】</h2><h2 id="【拓展】-2"><a href="#【拓展】-2" class="headerlink" title="【拓展】"></a>【拓展】</h2><h1 id="第四句"><a href="#第四句" class="headerlink" title="第四句"></a>第四句</h1><p>Two off-duty Rocky Mount, Virginia police officers, one of whom is an Army veteran and trained sniper, have been charged in federal court in connection to the infiltration and occupation of the U.S. Capitol building on Jan. 6, the U.S. Attorney’s Office for the District of Columbia announced Wednesday, adding to the growing list of law enforcement officers accused of taking part in the chaos at the Capitol. （Forbes）</p>
<h2 id="【词汇】-3"><a href="#【词汇】-3" class="headerlink" title="【词汇】"></a>【词汇】</h2><h2 id="【拓展】-3"><a href="#【拓展】-3" class="headerlink" title="【拓展】"></a>【拓展】</h2><h1 id="第五句"><a href="#第五句" class="headerlink" title="第五句"></a>第五句</h1><p>Markets opened lower Friday after President-elect Joe Biden released the details of his proposed $1.9 trillion coronavirus relief package in a speech the previous night, with investors likely reacting to the potential of a second Senate impeachment trial of President Trump in delaying passage of the legislation for weeks, along with the possibility of higher taxes in the incoming Democratic administration.（Forbes）</p>
<h2 id="【词汇】-4"><a href="#【词汇】-4" class="headerlink" title="【词汇】"></a>【词汇】</h2><h2 id="【拓展】-4"><a href="#【拓展】-4" class="headerlink" title="【拓展】"></a>【拓展】</h2><h1 id="第六句"><a href="#第六句" class="headerlink" title="第六句"></a>第六句</h1><p><u>Female-oriented</u> <u>dating app</u> Bumble, which <u>boasts</u> a feature that only allows women to make the move first, has half of the number of monthly active users of Badoo, <u>a much older</u> dating <u>product</u>, with a larger <u>presence</u> in Europe and Latin America — but Bumble’s core base is much more willing to pay. （Forbes）</p>
<h2 id="【词汇】-5"><a href="#【词汇】-5" class="headerlink" title="【词汇】"></a>【词汇】</h2><ul>
<li>female-oriented 以女性用户为导向的</li>
<li>dating app 约会应用</li>
<li>boast 拥有</li>
<li>product替换app</li>
<li>presence 影响力</li>
<li>core base 核心用户群<br>base 主要用户群</li>
</ul>
<h2 id="【拓展】-5"><a href="#【拓展】-5" class="headerlink" title="【拓展】"></a>【拓展】</h2><ul>
<li>customer/client/user+base 指主要用户群<br>voter base 选民基本盘</li>
<li><u>a much older</u> dating product…… 表示强调，强调历史久远得多</li>
</ul>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>21年Range·韧迹·看世界笔记</title>
    <url>/2021/01/18/Range21/</url>
    <content><![CDATA[<blockquote>
<p>本笔记配套课程为丁晓钟老师《Range·韧迹·看世界》课程，<a href="https://www.cctalk.com/m/group/89337346?xh_preshareid=21ffdabb-aca0-4329-b894-dc7f770c7a0e&xh_fshareuid=118391021&channel=copy&platform=pc">点击购买</a>与我共同进步~</p>
</blockquote>
<h1 id="1月20日-Trump-Farewell-Message"><a href="#1月20日-Trump-Farewell-Message" class="headerlink" title="1月20日 Trump Farewell Message"></a>1月20日 Trump Farewell Message</h1><p><div class="img-item" data-src="/assets/4.jpg" data-sub-html=".caption"><img src="/assets/4.jpg" alt="Trump Farewell Message"><div class="img-caption d-block text-center"><span class="center-caption text-muted border-bottom">Trump Farewell Message</span></div></div></p>
<blockquote>
<p>We did what we came here to do and so much more. This week we inaugurate a new administration and pray for its success in keeping America safe and prosperous. We extend our best wishes and we also want them to have luck.</p>
</blockquote>
<p><strong>【词汇】</strong></p>
<ul>
<li>inaugurate  为…举行就职典礼</li>
<li>pray for 为… 祈祷</li>
<li>prosperous 繁荣</li>
<li><u>extend</u> our best wishes <u>致以</u>我们最好的祝愿</li>
<li>【补】make a comeback 卷土重来</li>
</ul>
<blockquote>
<p>All Americans were horrified by the assault on our Capitol. Political violence is an attack on everything we cherish as Americans. It can never be tolerated. Now more than ever we must unify around our shared values and rise above the partisan rancor.</p>
</blockquote>
<p><strong>【词汇】</strong></p>
<ul>
<li>be horrified by 对…所感到震惊</li>
<li>political violence 政治暴力</li>
<li>cherish 珍视，珍惜</li>
<li>Now more than ever… 现在比以往任何时候都……</li>
<li>shared values 共同的价值观</li>
<li>rise above 超越</li>
<li>the partisan rancor 党派仇恨</li>
</ul>
<p><strong>【拓展】</strong></p>
<ul>
<li>造句：同样重要的是，我们必须竭尽全力维护我们作为文明社会成员所珍视的一切。<br>Equally important is that we must do all in our power to preserve everything we cherish as members of a civilized society.<br>也可以使用“It is equally important that …”</li>
</ul>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>重启博客</title>
    <url>/2021/01/16/hello-world/</url>
    <content><![CDATA[<p>当大家看见这篇文章，时隔我上一个博客关闭已接近两年。</p>
<p>这次，我打算重新开启我个人博客的记录。</p>
<p>我给我的博客取名“Alisa·外刊学习”，自然也就意味着这个博客的内容以<strong>分享我外刊学习</strong>为主，包括<strong>学习笔记、写作句型总结、学习心得</strong>，同时我的博客也会有关于我个人生活心得，其他内容的学习记录，但这不会占据我的博客太多位置。</p>
<p>关于学习外刊，有很多途径。英语基础较高的人可以直接订阅原版外刊杂志，比如经济学人，科学美国人等；基础一般或偏低的可以选择跟老师或者公众号学习，这里推荐丁晓钟老师的外刊课，他的授课注重<strong>逻辑、指代、替换、搭配</strong>等全方位语言基本功提升，他的课可以在cctalk和考虫平台上学习到，这边强烈推荐他的<strong>看世界</strong>课程。当然，其他的途径比如微信公众号经济学人双语精读中的Soren老师、在下林柏虎等也都是不错的老师。</p>
<p>当今世界，全球新冠疫情肆虐。在中华民族的的土地上，我们享受着国家和政府严控新冠带来的美好生活。于此，我们更应努力提升自己，为祖国的未来添砖加瓦。使用博客，记录自己成长的点点滴滴，拥抱美好而充实的生活！</p>
]]></content>
      <categories>
        <category>Random thoughts</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法说明</title>
    <url>/2017/03/05/2017-03-06-mdgrammer/</url>
    <content><![CDATA[<ul>
<li>content<br>{:toc}</li>
</ul>
<h1 id="Markdown-语法说明-简体中文版-点击查看快速入门"><a href="#Markdown-语法说明-简体中文版-点击查看快速入门" class="headerlink" title="Markdown 语法说明 (简体中文版) / (点击查看快速入门)"></a>Markdown 语法说明 (简体中文版) / (<a href="http://www.appinn.com/markdown/basic.html">点击查看快速入门</a>)</h1><hr>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="宗旨"><a href="#宗旨" class="headerlink" title="宗旨"></a>宗旨</h3><p>Markdown 的目标是实现「易读易写」。</p>
<p>可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 <a href="http://docutils.sourceforge.net/mirror/setext.html">Setext</a>、<a href="http://www.aaronsw.com/2002/atx/">atx</a>、<a href="http://textism.com/tools/textile/">Textile</a>、<a href="http://docutils.sourceforge.net/rst.html">reStructuredText</a>、<a href="http://www.triptico.com/software/grutatxt.html">Grutatext</a> 和 <a href="http://ettext.taint.org/doc/">EtText</a>，而最大灵感来源其实是纯文本电子邮件的格式。</p>
<p>总之， Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像<em>强调</em>。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。</p>
<h3 id="兼容-HTML"><a href="#兼容-HTML" class="headerlink" title="兼容 HTML"></a>兼容 HTML</h3><p>Markdown 语法的目标是：成为一种适用于网络的<em>书写</em>语言。</p>
<p>Markdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想<em>不是</em>要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种<em>发布</em>的格式，Markdown 是一种<em>书写</em>的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。</p>
<p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。</p>
<p>要制约的只有一些 HTML 区块元素――比如 <code>、</code>、<code>、</code> 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 `` 标签。</p>
<p>例子如下，在 Markdown 文件里加上一段 HTML 表格：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这是一个普通段落。</span><br><span class="line"></span><br><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;Foo&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;&#x2F;tr&gt;</span><br><span class="line">&lt;&#x2F;table&gt;</span><br><span class="line"></span><br><span class="line">这是另一个普通段落。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的<code>*强调*</code>会没有效果。</p>
<p>HTML 的区段（行内）标签如 <code>、</code>、<code>~~</code>~~ 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 <code>[</code>](undefined) 或 `` 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。</p>
<p>和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。</p>
<h3 id="特殊字符自动转换"><a href="#特殊字符自动转换" class="headerlink" title="特殊字符自动转换"></a>特殊字符自动转换</h3><p>在 HTML 文件中，有两个字符需要特殊处理： <code>&lt;</code> 和 <code>&amp;</code> 。 <code>&lt;</code> 符号用于起始标签，<code>&amp;</code> 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 <code>&lt;</code> 和 <code>&amp;</code>。</p>
<p><code>&amp;</code> 字符尤其让网络文档编写者受折磨，如果你要打「<code>AT&amp;T</code>」 ，你必须要写成「<code>AT&amp;T</code>」。而网址中的 <code>&amp;</code> 字符也要转换。比如你要链接到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;images.google.com&#x2F;images?num&#x3D;30&amp;q&#x3D;larry+bird</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你必须要把网址转换写为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;images.google.com&#x2F;images?num&#x3D;30&amp;q&#x3D;larry+bird</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>才能放到链接标签的 <code>href</code> 属性里。不用说也知道这很容易忽略，这也可能是 HTML 标准检验所检查到的错误中，数量最多的。</p>
<p>Markdown 让你可以自然地书写字符，需要转换的由它来处理好了。如果你使用的 <code>&amp;</code> 字符是 HTML 字符实体的一部分，它会保留原状，否则它会被转换成 <code>&amp;amp</code>;。</p>
<p>所以你如果要在文档中插入一个版权符号 <code>©</code>，你可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp;copy;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Markdown 会保留它不动。而若你写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AT&amp;T</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Markdown 就会将它转为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AT&amp;T</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>类似的状况也会发生在 <code>&lt;</code> 符号上，因为 Markdown 允许 <a href="http://www.appinn.com/markdown/#html">兼容 HTML</a> ，如果你是把 <code>&lt;</code> 符号作为 HTML 标签的定界符使用，那 Markdown 也不会对它做任何转换，但是如果你写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 &lt; 5</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Markdown 将会把它转换为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 &lt; 5</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>不过需要注意的是，code 范围内，不论是行内还是区块， <code>&lt;</code> 和 <code>&amp;</code> 两个符号都<em>一定</em>会被转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML code （和 HTML 相对而言， HTML 语法中，你要把所有的 <code>&lt;</code> 和 <code>&amp;</code> 都转换为 HTML 实体，才能在 HTML 文件里面写出 HTML code。）</p>
<hr>
<h2 id="区块元素"><a href="#区块元素" class="headerlink" title="区块元素"></a>区块元素</h2><h3 id="段落和换行"><a href="#段落和换行" class="headerlink" title="段落和换行"></a>段落和换行</h3><p>一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。</p>
<p>「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML 格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成 `` 标签。</p>
<p>如果你<em>确实</em>想要依赖 Markdown 来插入 `` 标签的话，在插入处先按入两个以上的空格然后回车。</p>
<p>的确，需要多费点事（多加空格）来产生 <code> ，但是简单地「每个换行都转换为 </code>」的方法在 Markdown 中并不适合， Markdown 中 email 式的 <a href="http://www.appinn.com/markdown/#blockquote">区块引用</a> 和多段落的 <a href="http://www.appinn.com/markdown/#list">列表</a> 在使用换行来排版的时候，不但更好用，还更方便阅读。</p>
<h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>Markdown 支持两种标题的语法，类 <a href="http://docutils.sourceforge.net/mirror/setext.html">Setext</a> 和类 <a href="http://www.aaronsw.com/2002/atx/">atx</a> 形式。</p>
<p>类 Setext 形式是用底线的形式，利用 <code>=</code> （最高阶标题）和 <code>-</code> （第二阶标题），例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This is an H1</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">This is an H2</span><br><span class="line">-------------</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>任何数量的 <code>=</code> 和 <code>-</code> 都可以有效果。</p>
<p>类 Atx 形式则是在行首插入 1 到 6 个 <code>#</code> ，对应到标题 1 到 6 阶，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 这是 H1</span><br><span class="line"></span><br><span class="line">## 这是 H2</span><br><span class="line"></span><br><span class="line">###### 这是 H6</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 <code>#</code>，而行尾的 <code>#</code> 数量也不用和开头一样（行首的井字符数量决定标题的阶数）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 这是 H1 #</span><br><span class="line"></span><br><span class="line">## 这是 H2 ##</span><br><span class="line"></span><br><span class="line">### 这是 H3 ######</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="区块引用-Blockquotes"><a href="#区块引用-Blockquotes" class="headerlink" title="区块引用 Blockquotes"></a>区块引用 Blockquotes</h3><p>Markdown 标记区块引用是使用类似 email 中用 <code>&gt;</code> 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 <code>&gt;</code> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,</span><br><span class="line">&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.</span><br><span class="line">&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</span><br><span class="line">&gt; </span><br><span class="line">&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse</span><br><span class="line">&gt; id sem consectetuer libero luctus adipiscing.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Markdown 也允许你偷懒只在整个段落的第一行最前面加上 <code>&gt;</code> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,</span><br><span class="line">consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.</span><br><span class="line">Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</span><br><span class="line"></span><br><span class="line">&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse</span><br><span class="line">id sem consectetuer libero luctus adipiscing.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 <code>&gt;</code> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; This is the first level of quoting.</span><br><span class="line">&gt;</span><br><span class="line">&gt; &gt; This is nested blockquote.</span><br><span class="line">&gt;</span><br><span class="line">&gt; Back to the first level.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; ## 这是一个标题。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 1.   这是第一行列表项。</span><br><span class="line">&gt; 2.   这是第二行列表项。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 给出一些例子代码：</span><br><span class="line">&gt; </span><br><span class="line">&gt;     return shell_exec(&quot;echo $input | $markdown_script&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择<em>增加引用阶层</em>。</p>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>Markdown 支持有序列表和无序列表。</p>
<p>无序列表使用星号、加号或是减号作为列表标记：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*   Red</span><br><span class="line">*   Green</span><br><span class="line">*   Blue</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+   Red</span><br><span class="line">+   Green</span><br><span class="line">+   Blue</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也等同于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-   Red</span><br><span class="line">-   Green</span><br><span class="line">-   Blue</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>有序列表则使用数字接着一个英文句点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.  Bird</span><br><span class="line">2.  McHale</span><br><span class="line">3.  Parish</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果，上面的列表所产生的 HTML 标记为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ol&gt;</span><br><span class="line">&lt;li&gt;Bird&lt;&#x2F;li&gt;</span><br><span class="line">&lt;li&gt;McHale&lt;&#x2F;li&gt;</span><br><span class="line">&lt;li&gt;Parish&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ol&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果你的列表标记写成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.  Bird</span><br><span class="line">1.  McHale</span><br><span class="line">1.  Parish</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>或甚至是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3. Bird</span><br><span class="line">1. McHale</span><br><span class="line">8. Parish</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你都会得到完全相同的 HTML 输出。重点在于，你可以让 Markdown 文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。</p>
<p>如果你使用懒惰的写法，建议第一个项目最好还是从 1. 开始，因为 Markdown 未来可能会支持有序列表的 start 属性。</p>
<p>列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。</p>
<p>要让列表看起来更漂亮，你可以把内容用固定的缩进整理好：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.</span><br><span class="line">    Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,</span><br><span class="line">    viverra nec, fringilla in, laoreet vitae, risus.</span><br><span class="line">*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.</span><br><span class="line">    Suspendisse id sem consectetuer libero luctus adipiscing.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是如果你懒，那也行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.</span><br><span class="line">Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,</span><br><span class="line">viverra nec, fringilla in, laoreet vitae, risus.</span><br><span class="line">*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.</span><br><span class="line">Suspendisse id sem consectetuer libero luctus adipiscing.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 `` 标签包起来，举例来说：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*   Bird</span><br><span class="line">*   Magic</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>会被转换为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;Bird&lt;&#x2F;li&gt;</span><br><span class="line">&lt;li&gt;Magic&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是这个：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*   Bird</span><br><span class="line"></span><br><span class="line">*   Magic</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>会被转换为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;&lt;p&gt;Bird&lt;&#x2F;p&gt;&lt;&#x2F;li&gt;</span><br><span class="line">&lt;li&gt;&lt;p&gt;Magic&lt;&#x2F;p&gt;&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.  This is a list item with two paragraphs. Lorem ipsum dolor</span><br><span class="line">    sit amet, consectetuer adipiscing elit. Aliquam hendrerit</span><br><span class="line">    mi posuere lectus.</span><br><span class="line"></span><br><span class="line">    Vestibulum enim wisi, viverra nec, fringilla in, laoreet</span><br><span class="line">    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum</span><br><span class="line">    sit amet velit.</span><br><span class="line"></span><br><span class="line">2.  Suspendisse id sem consectetuer libero luctus adipiscing.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*   This is a list item with two paragraphs.</span><br><span class="line"></span><br><span class="line">    This is the second paragraph in the list item. You&#39;re</span><br><span class="line">only required to indent the first line. Lorem ipsum dolor</span><br><span class="line">sit amet, consectetuer adipiscing elit.</span><br><span class="line"></span><br><span class="line">*   Another item in the same list.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果要在列表项目内放进引用，那 <code>&gt;</code> 就需要缩进：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*   A list item with a blockquote:</span><br><span class="line"></span><br><span class="line">    &gt; This is a blockquote</span><br><span class="line">    &gt; inside a list item.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果要放代码区块的话，该区块就需要缩进<em>两次</em>，也就是 8 个空格或是 2 个制表符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*   一列表项包含一个列表区块：</span><br><span class="line"></span><br><span class="line">        &lt;代码写在这&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当然，项目列表很可能会不小心产生，像是下面这样的写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1986. What a great season.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>换句话说，也就是在行首出现<em>数字-句点-空白</em>，要避免这样的状况，你可以在句点前面加上反斜杠。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1986\. What a great season.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h3><p>和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 <code> 和 </code> 标签来把代码区块包起来。</p>
<p>要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这是一个普通段落：</span><br><span class="line"></span><br><span class="line">    这是一个代码区块。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Markdown 会转换成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;这是一个普通段落：&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code&gt;这是一个代码区块。</span><br><span class="line">&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Here is an example of AppleScript:</span><br><span class="line"></span><br><span class="line">    tell application &quot;Foo&quot;</span><br><span class="line">        beep</span><br><span class="line">    end tell</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>会被转换为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;Here is an example of AppleScript:&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code&gt;tell application &quot;Foo&quot;</span><br><span class="line">    beep</span><br><span class="line">end tell</span><br><span class="line">&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。</p>
<p>在代码区块里面， <code>&amp;</code> 、 <code>&lt;</code> 和 <code>&gt;</code> 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;footer&quot;&gt;</span><br><span class="line">    &amp;copy; 2004 Foo Corporation</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>会被转换为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pre&gt;&lt;code&gt;&lt;div class&#x3D;&quot;footer&quot;&gt;</span><br><span class="line">    &amp;copy; 2004 Foo Corporation</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。</p>
<h3 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h3><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* * *</span><br><span class="line"></span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">*****</span><br><span class="line"></span><br><span class="line">- - -</span><br><span class="line"></span><br><span class="line">---------------------------------------</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="区段元素"><a href="#区段元素" class="headerlink" title="区段元素"></a>区段元素</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>Markdown 支持两种形式的链接语法： <em>行内式</em>和<em>参考式</em>两种形式。</p>
<p>不管是哪一种，链接文字都是用 [方括号] 来标记。</p>
<p>要建立一个<em>行内式</em>的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This is [an example](http:&#x2F;&#x2F;example.com&#x2F; &quot;Title&quot;) inline link.</span><br><span class="line"></span><br><span class="line">[This link](http:&#x2F;&#x2F;example.net&#x2F;) has no title attribute.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>会产生：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;This is &lt;a href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;&quot; title&#x3D;&quot;Title&quot;&gt;</span><br><span class="line">an example&lt;&#x2F;a&gt; inline link.&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;example.net&#x2F;&quot;&gt;This link&lt;&#x2F;a&gt; has no</span><br><span class="line">title attribute.&lt;&#x2F;p&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果你是要链接到同样主机的资源，你可以使用相对路径：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">See my [About](&#x2F;about&#x2F;) page for details.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><em>参考式</em>的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This is [an example][id] reference-style link.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你也可以选择性地在两个方括号中间加上一个空格：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This is [an example] [id] reference-style link.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接着，在文件的任意处，你可以把这个标记的链接内容定义出来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[id]: http:&#x2F;&#x2F;example.com&#x2F;  &quot;Optional Title Here&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>链接内容定义的形式为：</p>
<ul>
<li>方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字</li>
<li>接着一个冒号</li>
<li>接着一个以上的空格或制表符</li>
<li>接着链接的网址</li>
<li>选择性地接着 title 内容，可以用单引号、双引号或是括弧包着</li>
</ul>
<p>下面这三种链接的定义都是相同：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[foo]: http:&#x2F;&#x2F;example.com&#x2F;  &quot;Optional Title Here&quot;</span><br><span class="line">[foo]: http:&#x2F;&#x2F;example.com&#x2F;  &#39;Optional Title Here&#39;</span><br><span class="line">[foo]: http:&#x2F;&#x2F;example.com&#x2F;  (Optional Title Here)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>请注意：</strong>有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。</p>
<p>链接网址也可以用方括号包起来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[id]: &lt;http:&#x2F;&#x2F;example.com&#x2F;&gt;  &quot;Optional Title Here&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[id]: http:&#x2F;&#x2F;example.com&#x2F;longish&#x2F;path&#x2F;to&#x2F;resource&#x2F;here</span><br><span class="line">    &quot;Optional Title Here&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。</p>
<p>链接辨别标签可以有字母、数字、空白和标点符号，但是并<em>不</em>区分大小写，因此下面两个链接是一样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[link text][a]</span><br><span class="line">[link text][A]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><em>隐式链接标记</em>功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 “Google” 链接到 google.com，你可以简化成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Google][]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后定义链接内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Google]: http:&#x2F;&#x2F;google.com&#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Visit [Daring Fireball][] for more information.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后接着定义链接：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Daring Fireball]: http:&#x2F;&#x2F;daringfireball.net&#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。</p>
<p>下面是一个参考式链接的范例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I get 10 times more traffic from [Google] [1] than from</span><br><span class="line">[Yahoo] [2] or [MSN] [3].</span><br><span class="line"></span><br><span class="line">  [1]: http:&#x2F;&#x2F;google.com&#x2F;        &quot;Google&quot;</span><br><span class="line">  [2]: http:&#x2F;&#x2F;search.yahoo.com&#x2F;  &quot;Yahoo Search&quot;</span><br><span class="line">  [3]: http:&#x2F;&#x2F;search.msn.com&#x2F;    &quot;MSN Search&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果改成用链接名称的方式写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I get 10 times more traffic from [Google][] than from</span><br><span class="line">[Yahoo][] or [MSN][].</span><br><span class="line"></span><br><span class="line">  [google]: http:&#x2F;&#x2F;google.com&#x2F;        &quot;Google&quot;</span><br><span class="line">  [yahoo]:  http:&#x2F;&#x2F;search.yahoo.com&#x2F;  &quot;Yahoo Search&quot;</span><br><span class="line">  [msn]:    http:&#x2F;&#x2F;search.msn.com&#x2F;    &quot;MSN Search&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面两种写法都会产生下面的 HTML。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;I get 10 times more traffic from &lt;a href&#x3D;&quot;http:&#x2F;&#x2F;google.com&#x2F;&quot;</span><br><span class="line">title&#x3D;&quot;Google&quot;&gt;Google&lt;&#x2F;a&gt; than from</span><br><span class="line">&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;search.yahoo.com&#x2F;&quot; title&#x3D;&quot;Yahoo Search&quot;&gt;Yahoo&lt;&#x2F;a&gt;</span><br><span class="line">or &lt;a href&#x3D;&quot;http:&#x2F;&#x2F;search.msn.com&#x2F;&quot; title&#x3D;&quot;MSN Search&quot;&gt;MSN&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I get 10 times more traffic from [Google](http:&#x2F;&#x2F;google.com&#x2F; &quot;Google&quot;)</span><br><span class="line">than from [Yahoo](http:&#x2F;&#x2F;search.yahoo.com&#x2F; &quot;Yahoo Search&quot;) or</span><br><span class="line">[MSN](http:&#x2F;&#x2F;search.msn.com&#x2F; &quot;MSN Search&quot;).</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。</p>
<p>使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。</p>
<h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><p>Markdown 使用星号（<code>*</code>）和底线（<code>_</code>）作为标记强调字词的符号，被 <code>*</code> 或 <code>_</code> 包围的字词会被转成用 <code> 标签包围，用两个 `*` 或 `_`包起来的话，则会被转成 </code>，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*single asterisks*</span><br><span class="line"></span><br><span class="line">_single underscores_</span><br><span class="line"></span><br><span class="line">**double asterisks**</span><br><span class="line"></span><br><span class="line">__double underscores__</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>会转成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;em&gt;single asterisks&lt;&#x2F;em&gt;</span><br><span class="line"></span><br><span class="line">&lt;em&gt;single underscores&lt;&#x2F;em&gt;</span><br><span class="line"></span><br><span class="line">&lt;strong&gt;double asterisks&lt;&#x2F;strong&gt;</span><br><span class="line"></span><br><span class="line">&lt;strong&gt;double underscores&lt;&#x2F;strong&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。</p>
<p>强调也可以直接插在文字中间：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">un*frigging*believable</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是<strong>如果你的 * 和 _ 两边都有空白的话，它们就只会被当成普通的符号</strong>。</p>
<p>如果要在文字前后直接插入普通的星号或底线，你可以用反斜线：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\*this text is surrounded by literal asterisks\*</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>如果要标记一小段行内代码，你可以用反引号把它包起来（```），例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Use the &#96;printf()&#96; function.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>会产生：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;Use the &lt;code&gt;printf()&lt;&#x2F;code&gt; function.&lt;&#x2F;p&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#96;There is a literal backtick (&#96;) here.&#96;&#96;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这段语法会产生：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;&lt;code&gt;There is a literal backtick (&#96;) here.&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A single backtick in a code span: &#96;&#96; &#96; &#96;&#96;</span><br><span class="line"></span><br><span class="line">A backtick-delimited string in a code span: &#96;&#96; &#96;foo&#96; &#96;&#96;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>会产生：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;A single backtick in a code span: &lt;code&gt;&#96;&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;A backtick-delimited string in a code span: &lt;code&gt;&#96;foo&#96;&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在代码区段内，<code>&amp;</code> 和方括号<strong>都</strong>会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Please don&#39;t use any &#96;&lt;blink&gt;&#96; tags.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>转为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;Please don&#39;t use any &lt;code&gt;&lt;blink&gt;&lt;&#x2F;code&gt; tags.&lt;&#x2F;p&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你也可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&amp;#8212;&#96; is the decimal-encoded equivalent of &#96;&amp;mdash;&#96;.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以产生：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;&lt;code&gt;&amp;#8212;&lt;&#x2F;code&gt; is the decimal-encoded</span><br><span class="line">equivalent of &lt;code&gt;&amp;mdash;&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。</p>
<p>Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： <em>行内式</em>和<em>参考式</em>。</p>
<p>行内式的图片语法看起来像是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![Alt text](&#x2F;path&#x2F;to&#x2F;img.jpg)</span><br><span class="line"></span><br><span class="line">![Alt text](&#x2F;path&#x2F;to&#x2F;img.jpg &quot;Optional title&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>详细叙述如下：</p>
<ul>
<li>一个惊叹号 <code>!</code></li>
<li>接着一个方括号，里面放上图片的替代文字</li>
<li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字。</li>
</ul>
<p>参考式的图片语法则长得像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![Alt text][id]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>「id」是图片参考的名称，图片参考的定义方式则和连结参考一样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[id]: url&#x2F;to&#x2F;image  &quot;Optional title attribute&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 `` 标签。</p>
<hr>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h3><p>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;http:&#x2F;&#x2F;example.com&#x2F;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Markdown 会转为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;&quot;&gt;http:&#x2F;&#x2F;example.com&#x2F;&lt;&#x2F;a&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;address@example.com&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Markdown 会转成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;&amp;#x6D;&amp;#x61;i&amp;#x6C;&amp;#x74;&amp;#x6F;:&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;</span><br><span class="line">&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;</span><br><span class="line">&amp;#109;&quot;&gt;&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;</span><br><span class="line">&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;&lt;&#x2F;a&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在浏览器里面，这段字串（其实是 <code>[address@example.com](mailto:address@example.com)</code>）会变成一个可以点击的「<a href="mailto:&#x61;&#x64;&#x64;&#114;&#x65;&#115;&#x73;&#64;&#101;&#x78;&#97;&#x6d;&#x70;&#108;&#101;&#46;&#99;&#x6f;&#109;">&#x61;&#x64;&#x64;&#114;&#x65;&#115;&#x73;&#64;&#101;&#x78;&#97;&#x6d;&#x70;&#108;&#101;&#46;&#99;&#x6f;&#109;</a>」链接。</p>
<p>（这种作法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。）</p>
<h3 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠"></a>反斜杠</h3><p>Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 `` 标签），你可以在星号的前面加上反斜杠：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\*literal asterisks\*</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\   反斜线</span><br><span class="line">&#96;   反引号</span><br><span class="line">*   星号</span><br><span class="line">_   底线</span><br><span class="line">&#123;&#125;  花括号</span><br><span class="line">[]  方括号</span><br><span class="line">()  括弧</span><br><span class="line">#   井字号</span><br><span class="line">+   加号</span><br><span class="line">-   减号</span><br><span class="line">.   英文句点</span><br><span class="line">!   惊叹号</span><br></pre></td></tr></table></figure>
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
</search>
